<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>女孩与风 - 原型v1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ddd;
            height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            background: #1a1b1e;
            display: block;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            pointer-events: none;
            backdrop-filter: blur(5px);
            border-left: 2px solid #ff6b9d;
        }

        .controls div {
            margin-bottom: 5px;
            font-size: 13px;
            color: #aaa;
        }

        .controls strong {
            color: #fff;
            display: block;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            left: 30px;
            font-size: 24px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 2px;
        }

        .debug {
            display: none;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="level-indicator" id="levelIndicator">LEVEL 1</div>
        <div class="controls">
            <div><strong>Controls</strong></div>
            <div>MOUSE - Move Wind Source</div>
            <div>HOLD W/A/S/D - Blow Wind</div>
            <div>R - Restart Level</div>
            <div>1/2 - Switch Level</div>
        </div>
    </div>

    <div class="debug" id="debugInfo"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelIndicator = document.getElementById('levelIndicator');

        // Visual Style Constants
        const THEME = {
            bg: '#1a1b1e',
            grid: '#232428',
            wall: '#2a2b30',
            highlight: '#3a3b40',
            girl: '#ff6b9d',
            girlShadow: '#b03055',
            obstacle: '#333333',
            obstacleHighlight: '#444444',
            plank: '#cba', // Light minimalist wood/block
            plankShadow: '#876',
            wind: '#4ff',
            exit: '#44ffaa',
            gap: '#151619' // Slightly darker than BG
        };

        // Grid System
        const CELL_SIZE = 80;
        const GRID_W = 4;
        const GRID_H = 4;
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;

        // Calculate Grid Offset to center it
        const GRID_OFFSET_X = (GAME_WIDTH - (GRID_W * CELL_SIZE)) / 2;
        const GRID_OFFSET_Y = (GAME_HEIGHT - (GRID_H * CELL_SIZE)) / 2;

        // Configuration
        const GIRL_SIZE = 40; // Smaller relative to cell (half size) for "small" feel
        const GIRL_SPEED = 150; // Adjusted for larger scale


        // Helper for rounded rectangles
        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            return ctx;
        }

        // Particle System
        class Particle {
            constructor(x, y, type = 'dust') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1.0;

                if (type === 'dust') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    this.decay = 0.005 + Math.random() * 0.01;
                    this.size = 1 + Math.random() * 2;
                    this.color = `rgba(255, 255, 255, ${0.05 + Math.random() * 0.1})`;
                } else if (type === 'wind') {
                    this.vx = 0;
                    this.vy = 0;
                    this.decay = 0.02 + Math.random() * 0.03;
                    this.size = 2 + Math.random() * 3;
                    this.color = '#4ff';
                }
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= this.decay;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;

                if (this.type === 'wind') {
                    ctx.fillStyle = THEME.wind;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            spawn(x, y, type, count = 1) {
                for (let i = 0; i < count; i++) {
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    this.particles.push(new Particle(x + offsetX, y + offsetY, type));
                }
            }

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.update(dt);
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }

                // Always spawn background dust
                if (Math.random() < 0.2) {
                    this.spawn(
                        Math.random() * GAME_WIDTH,
                        Math.random() * GAME_HEIGHT,
                        'dust'
                    );
                }
            }

            draw(ctx) {
                for (let p of this.particles) {
                    p.draw(ctx);
                }
            }
        }

        const particles = new ParticleSystem();

        // Girl with "Thomas Was Alone" Aesthetics
        class Girl {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = GIRL_SIZE;
                this.height = GIRL_SIZE;
                // Goal will be set by level loader
                this.goalX = 0;
                this.goalY = 0;
                this.currentGoalX = 0;
                this.currentGoalY = 0;
                this.state = 'WALKING';
                this.speed = GIRL_SPEED;
                this.stateTimer = 0;
                this.detourPath = null;
                this.reachedWaypoint = false;

                // Animation
                this.bobOffset = 0;
                this.eyeOffset = 0;
            }

            update(dt, obstacles, blockages, gaps = []) {
                this.stateTimer += dt;

                // Simple bobbing animation
                this.bobOffset = Math.sin(Date.now() / 200) * 2;

                switch (this.state) {
                    case 'WALKING':
                    case 'WALKING_DETOUR':
                        this.eyeOffset = Math.sin(Date.now() / 150) * 2;
                        if (this.state === 'WALKING') this.updateWalking(dt, obstacles, gaps);
                        else this.updateWalkingDetour(dt, obstacles);

                        // Spawn trail particles occasionally
                        if (Math.random() < 0.1) {
                            particles.spawn(this.x + this.width / 2, this.y + this.height, 'dust');
                        }
                        break;
                    case 'STOPPED':
                        if (this.stateTimer > 0.3) {
                            this.state = 'TRY_PUSH';
                            this.stateTimer = 0;
                        }
                        break;
                    case 'TRY_PUSH':
                        if (this.stateTimer > 1.0) {
                            this.state = 'OBSERVE';
                            this.stateTimer = 0;
                        }
                        break;
                    case 'OBSERVE':
                        this.eyeOffset = 0;
                        if (this.stateTimer > 1.5) {
                            this.checkSolutions(blockages, gaps);
                        }
                        break;
                    case 'HESITATE':
                        if (this.stateTimer > 1.5) {
                            if (this.detourPath) {
                                this.state = 'WALKING_DETOUR';
                            } else {
                                this.state = 'WALKING';
                            }
                            this.stateTimer = 0;
                        }
                        break;
                }
            }

            checkSolutions(blockages, gaps) {
                let foundSolution = false;

                for (let blockage of blockages) {
                    if (!blockage.blocked && blockage.revealsPath) {
                        this.detourPath = blockage.revealsPath;
                        this.state = 'HESITATE';
                        this.stateTimer = 0;
                        foundSolution = true;
                        break;
                    }
                }

                if (!foundSolution && gaps) {
                    for (let gap of gaps) {
                        if (gap.isFilled) {
                            this.state = 'HESITATE';
                            this.stateTimer = 0;
                            foundSolution = true;
                            break;
                        }
                    }
                }

                if (!foundSolution) this.stateTimer = 0;
            }

            updateWalking(dt, obstacles, gaps) {
                const dx = this.currentGoalX - this.x;
                const dy = this.currentGoalY - this.y;

                // Manhattan Movement Logic
                // Prioritize the axis with larger distance, but don't move diagonally

                if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                    let moveX = 0;
                    let moveY = 0;

                    // Decide axis
                    // If we are significantly off on X, try X.
                    // If we are significantly off on Y, try Y.
                    // To avoid zig-zag on floating point errors, use a threshold or state?
                    // Simple approach: Move X until aligned, then Y. Or vice-versa.

                    // Let's verify which axis is free.
                    // But "Thomas Was Alone" style movement is usually one axis at a time cleanly.

                    // Strategy: If |dx| > |dy|, try X first.
                    if (Math.abs(dx) > Math.abs(dy)) {
                        moveX = Math.sign(dx) * this.speed * dt;
                    } else {
                        moveY = Math.sign(dy) * this.speed * dt;
                    }

                    // If we only chose one, and it's colliding, try the other?
                    // For now, strict Manhattan: X then Y or based on distance.
                    // Let's stick to: Move along X if X-dist is significant, else Y.
                    // Actually, let's prioritize strictly one axis to prevent "sliding" along walls diagonally.

                    if (Math.abs(dx) > 1) { // 1px threshold
                        moveX = Math.sign(dx) * this.speed * dt;
                        moveY = 0;
                    } else if (Math.abs(dy) > 1) {
                        moveX = 0;
                        moveY = Math.sign(dy) * this.speed * dt;
                    } else {
                        // Close enough
                        moveX = dx;
                        moveY = dy;
                    }

                    const nextX = this.x + moveX;
                    const nextY = this.y + moveY;

                    if (!this.checkCollision(nextX, nextY, obstacles, gaps)) {
                        this.x = nextX;
                        this.y = nextY;
                    } else {
                        // If colliding on preferred axis, try the other axis?
                        // This helps if trying to go X but hit a wall, maybe we should go Y?
                        // For this specific game level layout, strict waypoints usually handle this.
                        // But let's add a fallback:
                        if (moveX !== 0 && Math.abs(dy) > 1) {
                            // Try Y instead
                            const altY = this.y + Math.sign(dy) * this.speed * dt;
                            if (!this.checkCollision(this.x, altY, obstacles, gaps)) {
                                this.y = altY;
                            } else {
                                this.state = 'STOPPED';
                                this.stateTimer = 0;
                            }
                        } else if (moveY !== 0 && Math.abs(dx) > 1) {
                            // Try X instead
                            const altX = this.x + Math.sign(dx) * this.speed * dt;
                            if (!this.checkCollision(altX, this.y, obstacles, gaps)) {
                                this.x = altX;
                            } else {
                                this.state = 'STOPPED';
                                this.stateTimer = 0;
                            }
                        } else {
                            this.state = 'STOPPED';
                            this.stateTimer = 0;
                        }
                    }
                } else {
                    if (this.currentGoalX === this.goalX && this.currentGoalY === this.goalY) {
                        this.state = 'REACHED_GOAL';
                    }
                }
            }

            updateWalkingDetour(dt, obstacles) {
                if (!this.detourPath) return;
                const waypoint = this.detourPath.waypoint;

                if (!this.reachedWaypoint) {
                    const toX = waypoint.x - this.x;
                    const toY = waypoint.y - this.y;
                    const dist = Math.sqrt(toX * toX + toY * toY);

                    if (dist > 15) {
                        this.x += (toX / dist) * this.speed * dt;
                        this.y += (toY / dist) * this.speed * dt;
                    } else {
                        this.reachedWaypoint = true;
                    }
                } else {
                    const toX = this.goalX - this.x;
                    const toY = this.goalY - this.y;
                    const dist = Math.sqrt(toX * toX + toY * toY);

                    if (dist > 5) {
                        this.x += (toX / dist) * this.speed * dt;
                        this.y += (toY / dist) * this.speed * dt;
                    } else {
                        this.state = 'REACHED_GOAL';
                    }
                }
            }

            checkCollision(x, y, obstacles, gaps = []) {
                const margin = 2; // Provide a tiny bit of wiggle room
                for (let obs of obstacles) {
                    if (x + margin < obs.x + obs.width &&
                        x + this.width - margin > obs.x &&
                        y + margin < obs.y + obs.height &&
                        y + this.height - margin > obs.y) {
                        return true;
                    }
                }
                for (let gap of gaps) {
                    if (!gap.isFilled) {
                        if (x + margin < gap.x + gap.width &&
                            x + this.width - margin > gap.x &&
                            y + margin < gap.y + gap.height &&
                            y + this.height - margin > gap.y) {
                            return true;
                        }
                    }
                }
                return false;
            }

            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                roundRect(ctx, this.x + 5, this.y + 5 + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Body
                ctx.fillStyle = THEME.girl;
                roundRect(ctx, this.x, this.y + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Inner Highlights (Bevel effect)
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(this.x, this.y + this.bobOffset, this.width, 4);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(this.x, this.y + this.height - 4 + this.bobOffset, this.width, 4);

                // Expressions (Eyes)
                ctx.fillStyle = '#fff';
                const eyeY = this.y + this.height / 3 + this.bobOffset;

                // Normal Eyes
                let leftEyeX = this.x + 10 + this.eyeOffset;
                let rightEyeX = this.x + this.width - 14 + this.eyeOffset;
                let eyeH = 8;

                if (this.state === 'STOPPED' || this.state === 'HESITATE') {
                    // Looking up/thinking
                    eyeH = 4;
                }

                // Draw Eyes
                if (this.state !== 'REACHED_GOAL') {
                    ctx.fillRect(leftEyeX, eyeY, 4, eyeH);
                    ctx.fillRect(rightEyeX, eyeY, 4, eyeH);
                } else {
                    // Happy eyes ^ ^
                    ctx.beginPath();
                    ctx.moveTo(leftEyeX - 2, eyeY + 4);
                    ctx.lineTo(leftEyeX + 2, eyeY);
                    ctx.lineTo(leftEyeX + 6, eyeY + 4);

                    ctx.moveTo(rightEyeX - 2, eyeY + 4);
                    ctx.lineTo(rightEyeX + 2, eyeY);
                    ctx.lineTo(rightEyeX + 6, eyeY + 4);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Status Indicator (Bubble)
                if (['STOPPED', 'TRY_PUSH', 'OBSERVE', 'HESITATE', 'REACHED_GOAL'].includes(this.state)) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    let text = '';

                    if (this.state === 'STOPPED') text = '!';
                    else if (this.state === 'TRY_PUSH') text = '>';
                    else if (this.state === 'OBSERVE') text = '?';
                    else if (this.state === 'HESITATE') text = '...';
                    else if (this.state === 'REACHED_GOAL') text = '♥';

                    ctx.fillText(text, this.x + this.width / 2, this.y - 12 + this.bobOffset);
                }
            }
        }

        // Obstacle (Wall/Block)
        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.x + 4, this.y + 4, this.width, this.height);

                // Body
                ctx.fillStyle = THEME.obstacle;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Top Highlight
                ctx.fillStyle = THEME.obstacleHighlight;
                ctx.fillRect(this.x, this.y, this.width, 4);
            }
        }

        // Gap (Hole)
        class Gap {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isFilled = false;
            }

            checkFilled(movables) {
                for (let obj of movables) {
                    if (obj.x < this.x + this.width &&
                        obj.x + obj.width > this.x &&
                        obj.y < this.y + this.height &&
                        obj.y + obj.height > this.y) {

                        const overlapWidth = Math.min(obj.x + obj.width, this.x + this.width) - Math.max(obj.x, this.x);
                        const overlapHeight = Math.min(obj.y + obj.height, this.y + this.height) - Math.max(obj.y, this.y);
                        const overlapArea = overlapWidth * overlapHeight;
                        const gapArea = this.width * this.height;
                        const coverageRatio = overlapArea / gapArea;

                        this.coverageRatio = coverageRatio;

                        if (coverageRatio > 0.5) {
                            this.isFilled = true;
                            return;
                        }
                    }
                }
                this.isFilled = false;
                this.coverageRatio = 0;
            }

            draw(ctx) {
                if (!this.isFilled) {
                    // Inner shadow effect
                    ctx.fillStyle = THEME.gap;
                    ctx.fillRect(this.x, this.y, this.width, this.height);

                    // Inner borders to give depth
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(this.x, this.y, this.width, 10); // Top inner shadow
                    ctx.fillRect(this.x, this.y, 10, this.height); // Left inner shadow
                }
            }
        }

        // Movable Object (Plank/Block)
        class Movable {
            constructor(x, y, width, height, type = 'plank') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.90; // Increased friction for easier control
                this.mass = 2; // Increased mass
            }

            applyForce(fx, fy) {
                this.vx += fx / this.mass;
                this.vy += fy / this.mass;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vx *= this.friction;
                this.vy *= this.friction;

                if (Math.abs(this.vx) < 1) this.vx = 0;
                if (Math.abs(this.vy) < 1) this.vy = 0;

                // Limits (accounting for grid offset roughly, but clamping to canvas is safer)
                if (this.x < 0) { this.x = 0; this.vx = 0; }
                if (this.x + this.width > GAME_WIDTH) { this.x = GAME_WIDTH - this.width; this.vx = 0; }
                if (this.y < 0) { this.y = 0; this.vy = 0; }
                if (this.y + this.height > GAME_HEIGHT) { this.y = GAME_HEIGHT - this.height; this.vy = 0; }
            }

            draw(ctx) {
                if (this.type === 'plank') {
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    roundRect(ctx, this.x + 3, this.y + 3, this.width, this.height, 2);
                    ctx.fill();

                    // Body
                    ctx.fillStyle = '#a6825d'; // Darker, richer wood
                    roundRect(ctx, this.x, this.y, this.width, this.height, 2);
                    ctx.fill();

                    // Simple geometric detail (Inset)
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(this.x + 10, this.y + 10, this.width - 20, this.height - 20);
                }
            }
        }

        // Blockage (Hides secret path) - Redesigned as Sand/Debris Pile
        class Blockage {
            constructor(x, y, width, height, revealsPath = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.blocked = true;
                this.revealsPath = revealsPath;
                this.opacity = 1.0;
            }

            draw(ctx) {
                if (this.blocked) {
                    // Draw as a pile of sand/debris
                    // Using a semi-circle/mound shape
                    ctx.fillStyle = '#C2B280'; // Sand color

                    ctx.beginPath();
                    // Draw a mound shape
                    ctx.moveTo(this.x, this.y + this.height);
                    // Curvy top
                    ctx.bezierCurveTo(
                        this.x + this.width * 0.2, this.y + this.height * 0.4,
                        this.x + this.width * 0.8, this.y + this.height * 0.4,
                        this.x + this.width, this.y + this.height
                    );
                    ctx.closePath();
                    ctx.fill();

                    // Add texture/noise
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    for (let i = 0; i < 10; i++) {
                        const px = this.x + Math.random() * this.width;
                        const py = this.y + this.height / 2 + Math.random() * this.height / 2;
                        if (py > this.y + this.height) continue;
                        ctx.beginPath();
                        ctx.arc(px, py, 2 + Math.random() * 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Reveal path visual
                    if (this.revealsPath) {
                        // Draw guide line
                        const wp = this.revealsPath.waypoint;
                        ctx.strokeStyle = THEME.exit;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width / 2, this.y + this.height / 2);
                        ctx.lineTo(wp.x, wp.y);
                        // ctx.stroke(); 
                        ctx.setLineDash([]);

                        // Draw Waypoint marker
                        ctx.fillStyle = THEME.exit;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(wp.x, wp.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }

        // Wind System
        class Wind {
            constructor() {
                this.x = GAME_WIDTH / 2;
                this.y = 50;
                this.active = false;
                this.direction = { x: 0, y: 1 };
                this.strength = 150; // Reduced from 300 to 150
                this.size = 30;
                this.timer = 0;
                this.streams = []; // For visual effect
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
            }

            setDirection(key) {
                switch (key) {
                    case 'w': case 'W': this.direction = { x: 0, y: -1 }; break;
                    case 's': case 'S': this.direction = { x: 0, y: 1 }; break;
                    case 'a': case 'A': this.direction = { x: -1, y: 0 }; break;
                    case 'd': case 'D': this.direction = { x: 1, y: 0 }; break;
                }
            }

            activate() {
                this.active = true;
            }

            stop() {
                this.active = false;
            }

            checkBlockages(blockages) {
                if (!this.active) return false;
                const windReach = 200;

                for (let blockage of blockages) {
                    if (!blockage.blocked) continue;

                    const toBlockageX = blockage.x + blockage.width / 2 - this.x;
                    const toBlockageY = blockage.y + blockage.height / 2 - this.y;
                    const distance = Math.sqrt(toBlockageX * toBlockageX + toBlockageY * toBlockageY);

                    if (distance < windReach) {
                        const dot = (toBlockageX * this.direction.x + toBlockageY * this.direction.y) / distance;
                        if (dot > 0.6) {
                            blockage.blocked = false;

                            // Explosion effect
                            particles.spawn(blockage.x + blockage.width / 2, blockage.y + blockage.height / 2, 'dust', 10);
                            return true;
                        }
                    }
                }
                return false;
            }

            pushMovables(movables) {
                if (!this.active) return;
                const windReach = 250;

                for (let obj of movables) {
                    const toObjX = obj.x + obj.width / 2 - this.x;
                    const toObjY = obj.y + obj.height / 2 - this.y;
                    const distance = Math.sqrt(toObjX * toObjX + toObjY * toObjY);

                    if (distance < windReach) {
                        const dot = (toObjX * this.direction.x + toObjY * this.direction.y) / distance;
                        if (dot > 0.5) {
                            const forceMagnitude = this.strength * (1 - distance / windReach);
                            const fx = this.direction.x * forceMagnitude;
                            const fy = this.direction.y * forceMagnitude;
                            obj.applyForce(fx, fy);

                            // Interaction particles
                            if (Math.random() < 0.1) {
                                particles.spawn(obj.x + obj.width / 2, obj.y + obj.height / 2, 'wind');
                            }
                        }
                    }
                }
            }

            draw(ctx) {
                this.timer += 0.1;

                if (this.active) {
                    // Update streams
                    if (Math.random() < 0.3) {
                        this.streams.push({
                            x: this.x + (Math.random() - 0.5) * 40,
                            y: this.y + (Math.random() - 0.5) * 40,
                            len: 0,
                            maxLen: 50 + Math.random() * 100,
                            alpha: 1.0,
                            width: 2 + Math.random() * 3
                        });
                    }
                }

                // Draw streams
                for (let i = this.streams.length - 1; i >= 0; i--) {
                    let s = this.streams[i];
                    s.len += 10;
                    s.alpha -= 0.05;
                    s.x += this.direction.x * 5;
                    s.y += this.direction.y * 5;

                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x + this.direction.x * s.len, s.y + this.direction.y * s.len);
                    ctx.strokeStyle = `rgba(100, 255, 255, ${s.alpha * 0.5})`;
                    ctx.lineWidth = s.width;
                    ctx.stroke();

                    if (s.alpha <= 0) this.streams.splice(i, 1);
                }

                // Cursor visual
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.stroke();

                if (this.active) {
                    // Wind gusts visual (lines)
                    const endX = this.x + this.direction.x * 150;
                    const endY = this.y + this.direction.y * 150;

                    const grad = ctx.createLinearGradient(this.x, this.y, endX, endY);
                    grad.addColorStop(0, 'rgba(100, 255, 255, 0.0)');
                    grad.addColorStop(0.2, 'rgba(100, 255, 255, 0.3)');
                    grad.addColorStop(1, 'rgba(100, 255, 255, 0.0)');

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 40;
                    ctx.lineCap = 'round';
                    // Using a blurred line for "air" feel?
                    // Canvas doesn't support easy blur on stroke without filter
                    // Just accept the gradient for now as a "beam"
                    ctx.stroke();
                }
            }
        }

        // 游戏状态
        let currentLevel = 1;
        let girl = null;
        let obstacles = [];
        let blockages = [];
        let gaps = [];
        let movables = [];
        let wind = new Wind();

        // Helper to get grid position
        function getGridPos(col, row) {
            return {
                x: GRID_OFFSET_X + col * CELL_SIZE,
                y: GRID_OFFSET_Y + row * CELL_SIZE
            };
        }

        // 第一关的布局
        function setupLevel1() {
            obstacles = [];
            blockages = [];
            gaps = [];
            movables = [];

            const startPos = getGridPos(0, 1.5);

            // Fix: Align Start Position to Row 1 exactly to allow walking
            // Girl works best when aligned to grid for simple path finding
            // Center girl on (0, 1) to avoid clipping obstacle at (2, 1)
            let safeStart = getGridPos(0, 1);

            girl = new Girl(safeStart.x + (CELL_SIZE - GIRL_SIZE) / 2, safeStart.y + (CELL_SIZE - GIRL_SIZE) / 2);
            girl.goalX = getGridPos(3, 1).x + (CELL_SIZE - GIRL_SIZE) / 2;
            girl.goalY = getGridPos(3, 1).y + (CELL_SIZE - GIRL_SIZE) / 2;
            girl.currentGoalX = girl.goalX;
            girl.currentGoalY = girl.goalY;

            // Obstacle at (2, 1)
            const obsPos = getGridPos(2, 1);
            obstacles.push(new Obstacle(obsPos.x, obsPos.y, CELL_SIZE, CELL_SIZE));

            // The logic: Girl wants to go (0,1) -> (3,1), blocked by (2,1)
            // She checks for detour.
            // Blockage at (1, 2) hides detour.
            const blockPos = getGridPos(1, 2);

            // Waypoint for detour at (2, 2)
            // Ensure path (1,2) -> (2,2) -> (3,2) -> (3,1) is viable
            // The blockage is at (1,2), so when it opens, she can walk to (2,2).
            const detourWaypoint = getGridPos(2, 2);
            detourWaypoint.x += CELL_SIZE / 2; // Center
            detourWaypoint.y += CELL_SIZE / 2;

            blockages.push(new Blockage(
                blockPos.x, blockPos.y, CELL_SIZE, CELL_SIZE,
                { waypoint: detourWaypoint }
            ));
        }

        // 第二关的布局
        function setupLevel2() {
            obstacles = [];
            blockages = [];
            gaps = [];
            movables = [];

            const startPos = getGridPos(0, 1);
            girl = new Girl(startPos.x + (CELL_SIZE - GIRL_SIZE) / 2, startPos.y + (CELL_SIZE - GIRL_SIZE) / 2);
            girl.goalX = getGridPos(3, 1).x + (CELL_SIZE - GIRL_SIZE) / 2;
            girl.goalY = getGridPos(3, 1).y + (CELL_SIZE - GIRL_SIZE) / 2;
            girl.currentGoalX = girl.goalX;
            girl.currentGoalY = girl.goalY;

            // Gap at (2, 1)
            const gapPos = getGridPos(2, 1);
            gaps.push(new Gap(gapPos.x, gapPos.y, CELL_SIZE, CELL_SIZE));

            // Plank available at (1, 2)
            // Fixed: Make plank larger to fit grid
            const plankPos = getGridPos(1, 2);
            movables.push(new Movable(plankPos.x, plankPos.y, CELL_SIZE, CELL_SIZE, 'plank'));
        }

        // 加载关卡
        function loadLevel(level) {
            currentLevel = level;
            levelIndicator.innerText = `LEVEL ${level}`;
            if (level === 1) setupLevel1();
            else if (level === 2) setupLevel2();
        }

        // 初始化
        loadLevel(1);

        // 输入处理
        let mouseX = GAME_WIDTH / 2;
        let mouseY = 50;
        let activeKeys = new Set();

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates if canvas is styled different than logical size
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;
            wind.setPosition(mouseX, mouseY);
        });

        document.addEventListener('keydown', (e) => {
            if (activeKeys.has(e.key.toLowerCase())) return;

            if (['w', 'W', 'a', 'A', 's', 'S', 'd', 'D'].includes(e.key)) {
                e.preventDefault();
                activeKeys.add(e.key.toLowerCase());
                wind.setDirection(e.key);
                wind.activate();
                wind.checkBlockages(blockages);
            } else if (e.key === 'r' || e.key === 'R') {
                loadLevel(currentLevel);
            } else if (e.key === '1') {
                loadLevel(1);
            } else if (e.key === '2') {
                loadLevel(2);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (['w', 'W', 'a', 'A', 's', 'S', 'd', 'D'].includes(e.key)) {
                activeKeys.delete(e.key.toLowerCase());
                if (!activeKeys.has('w') && !activeKeys.has('a') &&
                    !activeKeys.has('s') && !activeKeys.has('d')) {
                    wind.stop();
                }
            }
        });

        // 游戏循环
        let lastTime = Date.now();

        function gameLoop() {
            const now = Date.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            // Updates
            for (let obj of movables) obj.update(dt);
            for (let gap of gaps) gap.checkFilled(movables);
            if (girl) girl.update(dt, obstacles, blockages, gaps);

            if (wind.active) {
                wind.pushMovables(movables);
                wind.checkBlockages(blockages);
            }

            particles.update(dt);

            // Draw
            // 1. Background
            ctx.fillStyle = THEME.bg;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // 2. Draw Grid (Subtle)
            ctx.save();
            ctx.translate(GRID_OFFSET_X, GRID_OFFSET_Y);
            for (let r = 0; r < GRID_H; r++) {
                for (let c = 0; c < GRID_W; c++) {
                    ctx.fillStyle = THEME.grid;
                    // Slightly smaller than cell to leave gaps
                    ctx.fillRect(c * CELL_SIZE + 2, r * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                }
            }
            ctx.restore();

            // 3. Draw Entities

            // Exit Marker (New)
            if (girl) {
                // Determine exit position (goal)
                // Draw a glowing floor plate
                ctx.save();
                const exitX = girl.goalX + GIRL_SIZE / 2;
                const exitY = girl.goalY + GIRL_SIZE / 2;
                const exitRadius = 30 + Math.sin(now / 500) * 5;

                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.2)'; // Warm Orange/Yellow
                ctx.fill();

                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.4)';
                ctx.fill();

                // Light beam
                const grad = ctx.createLinearGradient(exitX, exitY, exitX, exitY - 100);
                grad.addColorStop(0, 'rgba(255, 170, 51, 0.3)');
                grad.addColorStop(1, 'rgba(255, 170, 51, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(exitX - 20, exitY - 100, 40, 100);

                ctx.restore();
            }

            for (let gap of gaps) gap.draw(ctx);
            for (let obs of obstacles) obs.draw(ctx);
            for (let blockage of blockages) blockage.draw(ctx);
            for (let obj of movables) obj.draw(ctx);
            if (girl) girl.draw(ctx);

            // 4. Draw Particles
            particles.draw(ctx);

            // 5. Draw Wind
            wind.draw(ctx);

            // 6. Lighting / Vignette Overlay
            const gradient = ctx.createRadialGradient(
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 200,
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 500
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            requestAnimationFrame(gameLoop);
        }

        // 启动游戏
        gameLoop();
    </script>
</body>

</html>