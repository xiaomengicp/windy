<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>女孩与风 - 原型v1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ddd;
            height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            background: #1a1b1e;
            display: block;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            pointer-events: none;
            backdrop-filter: blur(5px);
            border-left: 2px solid #ff6b9d;
        }

        .controls div {
            margin-bottom: 5px;
            font-size: 13px;
            color: #aaa;
        }

        .controls strong {
            color: #fff;
            display: block;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            left: 30px;
            font-size: 24px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 2px;
        }

        .debug {
            display: none;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="level-indicator" id="levelIndicator">LEVEL 1</div>
        <div class="controls">
            <div><strong>Controls</strong></div>
            <div>MOUSE - Move Wind Source</div>
            <div>HOLD W/A/S/D - Blow Wind</div>
            <div>R - Restart Level</div>
            <div>1/2 - Switch Level</div>
        </div>
    </div>

    <div class="debug" id="debugInfo"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelIndicator = document.getElementById('levelIndicator');

        // Visual Style Constants
        const THEME = {
            bg: '#1a1b1e',
            grid: '#232428',
            wall: '#2a2b30',
            highlight: '#3a3b40',
            girl: '#ff6b9d',
            girlShadow: '#b03055',
            obstacle: '#333333',
            obstacleHighlight: '#444444',
            plank: '#cba', // Light minimalist wood/block
            plankShadow: '#876',
            wind: '#4ff',
            exit: '#44ffaa',
            gap: '#151619' // Slightly darker than BG
        };

        // Grid System
        const CELL_SIZE = 80;
        const GRID_W = 4;
        const GRID_H = 4;
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;

        // Calculate Grid Offset to center it
        const GRID_OFFSET_X = (GAME_WIDTH - (GRID_W * CELL_SIZE)) / 2;
        const GRID_OFFSET_Y = (GAME_HEIGHT - (GRID_H * CELL_SIZE)) / 2;

        // Configuration
        const GIRL_SIZE = 40; // Smaller relative to cell (half size) for "small" feel
        const GIRL_SPEED = 150; // Adjusted for larger scale


        // Helper for rounded rectangles
        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            return ctx;
        }

        // Particle System
        class Particle {
            constructor(x, y, type = 'dust') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1.0;

                if (type === 'dust') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    this.decay = 0.005 + Math.random() * 0.01;
                    this.size = 1 + Math.random() * 2;
                    this.color = `rgba(255, 255, 255, ${0.05 + Math.random() * 0.1})`;
                } else if (type === 'wind') {
                    this.vx = 0;
                    this.vy = 0;
                    this.decay = 0.02 + Math.random() * 0.03;
                    this.size = 2 + Math.random() * 3;
                    this.color = '#4ff';
                }
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= this.decay;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;

                if (this.type === 'wind') {
                    ctx.fillStyle = THEME.wind;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            spawn(x, y, type, count = 1) {
                for (let i = 0; i < count; i++) {
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    this.particles.push(new Particle(x + offsetX, y + offsetY, type));
                }
            }

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.update(dt);
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }

                // Always spawn background dust
                if (Math.random() < 0.2) {
                    this.spawn(
                        Math.random() * GAME_WIDTH,
                        Math.random() * GAME_HEIGHT,
                        'dust'
                    );
                }
            }

            draw(ctx) {
                for (let p of this.particles) {
                    p.draw(ctx);
                }
            }
        }

        const particles = new ParticleSystem();

        // Girl with "Thomas Was Alone" Aesthetics
        class Girl {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = GIRL_SIZE;
                this.height = GIRL_SIZE;
                this.goalX = GAME_WIDTH - 50;
                this.goalY = GAME_HEIGHT / 2;

                // Final Goal (The Exit) - Persistent
                this.finalGoalX = this.goalX;
                this.finalGoalY = this.goalY;

                // currentGoal is the IMMEDIATE waypoint we are walking towards
                this.currentGoalX = this.goalX;
                this.currentGoalY = this.goalY;

                // Waypoint Queue for L-Shaped movement
                this.pathQueue = [];

                this.state = 'WALKING';
                this.speed = GIRL_SPEED;
                this.color = '#ff6b9d';
                this.stateTimer = 0;

                this.stateTimer = 0;

                this.detourPath = null;
                this.hasDetoured = false; // Flag to prevent re-taking the same detour
                this.reachedWaypoint = false;

                // Animation
                this.bobOffset = 0;
                this.eyeOffset = { x: 0, y: 0 };
                this.blinkTimer = 0;
                this.expression = '';
            }

            update(dt, obstacles, blockages, gaps) {
                // Update animation state
                this.bobOffset = Math.sin(Date.now() / 150) * 2;
                if (Math.random() < 0.01) this.blinkTimer = 10;
                if (this.blinkTimer > 0) this.blinkTimer--;

                // Logic State Machine
                switch (this.state) {
                    case 'WALKING':
                        this.updateWalking(dt, obstacles, gaps);

                        // Spawn trail particles
                        if (Math.random() < 0.1) {
                            particles.spawn(this.x + this.width / 2, this.y + this.height, 'dust');
                        }

                        // Check if we ran into a blockage (collision handled in walking, but this is for specific state trigger)
                        // Actually, updateWalking handles collision by stopping.
                        // We need to check if we are "stuck" or "blocked" by logic, not just physics.
                        // If pathQueue is empty but we haven't reached final goal, we might be blocked.

                        // Check collision with Blockages specifically to trigger "BLOCKED" state
                        for (let b of blockages) {
                            if (b.blocked && this.checkCollision(this.x, this.y, [b], [])) {
                                this.state = 'BLOCKED';
                                this.stateTimer = 0;
                                this.expression = '!';
                                // Bounce back a bit
                                this.x -= Math.sign(this.currentGoalX - this.x) * 5;
                                this.y -= Math.sign(this.currentGoalY - this.y) * 5;
                                this.pathQueue = []; // Clear path
                            }
                        }
                        break;

                    case 'BLOCKED':
                        // 1. Bounce -> Stop
                        // 2. Expression '?'
                        this.stateTimer += dt;
                        this.expression = '?';
                        if (this.stateTimer > 1.0) {
                            this.state = 'TRY_PUSH';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'TRY_PUSH':
                        // 3. Expression '>' (Trying to move forward)
                        this.expression = '>';
                        this.stateTimer += dt;

                        // Small "pushing" animation
                        this.x += (Math.random() - 0.5) * 1;
                        this.y += (Math.random() - 0.5) * 1;

                        if (this.stateTimer > 0.8) {
                            this.state = 'THINKING';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'STOPPED':
                        // Generic stop from collision or just idle
                        this.stateTimer += dt;
                        this.expression = '?';
                        if (this.stateTimer > 1.0) {
                            this.state = 'TRY_PUSH';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'THINKING':
                        this.stateTimer += dt;
                        this.expression = '...';

                        // Check for world changes (detours opened, gaps filled)
                        if (this.checkEnvironment(blockages, gaps)) {
                            // EVENT: Path Cleared
                            this.state = 'HESITATE';
                            this.stateTimer = 0;
                            this.expression = '!'; // Idea!
                        } else {
                            // If no solution found, keep thinking or retry walking random?
                            // Loop back to Trying to Push or just stay Thinking
                            if (this.stateTimer > 2.0) {
                                this.state = 'STOPPED'; // Loop back
                                this.stateTimer = 0;
                            }
                        }
                        break;

                    case 'HESITATE':
                        // 5. Hesitate '!'
                        this.stateTimer += dt;
                        this.expression = '!';
                        if (this.stateTimer > 0.8) {
                            this.state = 'ASSESS';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'ASSESS':
                        // 6. Assess '...'
                        this.stateTimer += dt;
                        this.expression = '...';
                        if (this.stateTimer > 1.0) {
                            this.state = 'WALKING';
                            this.expression = '';
                        }
                        break;

                    case 'REACHED_GOAL':
                        this.expression = '♥';
                        break;
                }

                // Always try to plan path if walking
                if (this.state === 'WALKING') {
                    this.planPath(obstacles, blockages);
                }

                // Detour Completion Logic
                if (this.detourPath) {
                    // Check if reached waypoint (currentGoal/goal)
                    // If pathQueue is empty and we are close to goal
                    if (this.pathQueue.length === 0 && Math.abs(this.x - this.goalX) < 10 && Math.abs(this.y - this.goalY) < 10) {
                        this.reachedWaypoint = true;

                        // Fix: Back to Final Goal
                        this.goalX = this.finalGoalX;
                        this.goalY = this.finalGoalY;
                        this.currentGoalX = this.finalGoalX;
                        this.currentGoalY = this.finalGoalY;

                        this.pathQueue = []; // Force recalc path to final goal
                        this.detourPath = null;
                        this.state = 'WALKING'; // Ensure we keep walking
                        this.hasDetoured = true; // Mark as done so we don't go back
                    }
                }
            }

            checkEnvironment(blockages, gaps) {
                // Logic to update goal based on environment

                // Level 1: Check if blocking block is cleared
                if (currentLevel === 1) {
                    // Check if we are trying to go to main goal but blocked?
                    // Just check if any blockage revealing path is now CLEARED
                    const detourBlock = blockages.find(b => b.revealsPath && !b.blocked);

                    if (detourBlock && !this.hasDetoured) {
                        // Detour is open!
                        // Check if we are already using it?
                        if (this.goalX !== detourBlock.revealsPath.waypoint.x) {
                            // New goal!
                            this.goalX = detourBlock.revealsPath.waypoint.x;
                            this.goalY = detourBlock.revealsPath.waypoint.y;
                            this.currentGoalX = this.goalX;
                            this.currentGoalY = this.goalY;
                            this.pathQueue = []; // Force recalc
                            this.detourPath = true;
                            return true;
                        }
                    }
                }

                // Level 2: Check for filled gaps
                if (currentLevel === 2) {
                    // If gap filled, maybe we can cross?
                    const filledGap = gaps.find(g => g.isFilled);
                    if (filledGap) {
                        // Simply returning true to trigger HESITATE -> WALKING
                        // planPath needs to be smart enough to walk over it now.
                        // checkCollision already handles isFilled.
                        return true;
                    }
                }

                return false;
            }
            planPath(obstacles, blockages) {
                // Determine high-level Goal (Final destination or Detour)
                // If we have a detour and haven't reached it, target detour.
                let finalTargetX = this.goalX;
                let finalTargetY = this.goalY;

                // Check if direct path is blocked by a Blockage entity
                // If so, look for detour
                // This is specific "AI" logic for the level
                if (currentLevel === 1) {
                    const mainBlockage = obstacles.find(o => o.y === this.y || Math.abs(o.y - this.y) < 10);
                    // Actually, let's keep it simple:
                    // If we are at the detour start (Logic handled in updateWalking to trigger detour)
                }

                // If queue is empty, we need to generate a path to finalTarget
                if (this.pathQueue.length === 0 && (Math.abs(this.x - finalTargetX) > 5 || Math.abs(this.y - finalTargetY) > 5)) {
                    // Generate L-shaped path
                    this.generatePath(finalTargetX, finalTargetY, obstacles);
                }
            }

            generatePath(tx, ty, obstacles) {
                // Simple L-shape generator:
                // Option A: X then Y
                // Option B: Y then X
                // Check which one is valid (no obstacles)

                let pathA = [
                    { x: tx, y: this.y }, // Intermediate (move X, same Y)
                    { x: tx, y: ty }      // Final
                ];

                let pathB = [
                    { x: this.x, y: ty }, // Intermediate (move Y, same X)
                    { x: tx, y: ty }      // Final
                ];

                // Validate Path A (Check segment from Current to Inter, and Inter to Final)
                // Simplification: Check intermediate point collision? No, need line check.
                // For grid-like game, checking the corners/intermediate box is usually enough.

                /* 
                   We want to find a path that doesn't collide.
                   Let's prioritize: Go X if |dx| > |dy| (unless blocked).
                 */

                const dx = tx - this.x;
                const dy = ty - this.y;

                // If already aligned on one axis, just push final
                if (Math.abs(dx) < 5 || Math.abs(dy) < 5) {
                    this.pathQueue = [{ x: tx, y: ty }];
                    return;
                }

                // Default: Try X then Y
                let firstPoint = { x: tx, y: this.y };
                // Check if `firstPoint` is safe (and the path to it)
                if (!this.checkCollision(firstPoint.x, firstPoint.y, obstacles, [])) {
                    this.pathQueue = [firstPoint, { x: tx, y: ty }];
                } else {
                    // Try Y then X
                    this.pathQueue = [{ x: this.x, y: ty }, { x: tx, y: ty }];
                }
            }

            updateWalking(dt, obstacles, gaps) {
                // Consume Queue

                if (this.pathQueue.length === 0) return;

                const target = this.pathQueue[0];
                this.currentGoalX = target.x;
                this.currentGoalY = target.y;

                const dx = this.currentGoalX - this.x;
                const dy = this.currentGoalY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 5) {
                    // Reached waypoint
                    this.x = this.currentGoalX;
                    this.y = this.currentGoalY;
                    this.pathQueue.shift(); // Remove reached waypoint
                    return;
                }

                // Move towards current waypoint (Strictly on axis usually, but since we decomposed to L-shape, 
                // one of dx/dy should be ~0. If floating point mess, we force it.)

                let moveX = 0;
                let moveY = 0;

                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = Math.sign(dx) * this.speed * dt;
                } else {
                    moveY = Math.sign(dy) * this.speed * dt;
                }

                const nextX = this.x + moveX;
                const nextY = this.y + moveY;

                if (!this.checkCollision(nextX, nextY, obstacles, gaps)) {
                    this.x = nextX;
                    this.y = nextY;
                } else {
                    // Bonk
                    this.state = 'STOPPED';
                    this.stateTimer = 0;
                    // Clear queue to recalc options?
                    this.pathQueue = [];
                }
            }

            checkCollision(x, y, obstacles, gaps) {
                // ... existing collision logic ...
                // Need to use temporary rect
                // Girl is GIRL_SIZE (40)
                for (let obs of obstacles) {
                    if (x < obs.x + obs.width &&
                        x + this.width > obs.x &&
                        y < obs.y + obs.height &&
                        y + this.height > obs.y) {
                        return true;
                    }
                }

                // Gaps logic (only if not filled)
                for (let gap of gaps) {
                    if (!gap.isFilled &&
                        x < gap.x + gap.width &&
                        x + this.width > gap.x &&
                        y < gap.y + gap.height &&
                        y + this.height > gap.y) {

                        // Check strict overlap (center point?)
                        // If center of girl is inside gap
                        const cx = x + this.width / 2;
                        const cy = y + this.height / 2;
                        if (cx > gap.x && cx < gap.x + gap.width &&
                            cy > gap.y && cy < gap.y + gap.height) {
                            return true; // Fall in gap
                        }
                    }
                }
                return false;
            }

            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                roundRect(ctx, this.x + 5, this.y + 5 + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Body
                ctx.fillStyle = THEME.girl;
                roundRect(ctx, this.x, this.y + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Inner Highlights (Bevel effect)
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(this.x, this.y + this.bobOffset, this.width, 4);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(this.x, this.y + this.height - 4 + this.bobOffset, this.width, 4);

                // Expressions (Eyes)
                ctx.fillStyle = '#fff';
                const eyeY = this.y + this.height / 3 + this.bobOffset;

                // Normal Eyes
                let leftEyeX = this.x + 10 + this.eyeOffset.x;
                let rightEyeX = this.x + this.width - 14 + this.eyeOffset.x;
                let eyeH = 8;

                if (this.blinkTimer > 0) {
                    eyeH = 2; // Blinking
                }

                // Draw Eyes
                if (this.state !== 'REACHED_GOAL') {
                    ctx.fillRect(leftEyeX, eyeY, 4, eyeH);
                    ctx.fillRect(rightEyeX, eyeY, 4, eyeH);
                } else {
                    // Happy eyes ^ ^
                    ctx.beginPath();
                    ctx.moveTo(leftEyeX - 2, eyeY + 4);
                    ctx.lineTo(leftEyeX + 2, eyeY);
                    ctx.lineTo(leftEyeX + 6, eyeY + 4);

                    ctx.moveTo(rightEyeX - 2, eyeY + 4);
                    ctx.lineTo(rightEyeX + 2, eyeY);
                    ctx.lineTo(rightEyeX + 6, eyeY + 4);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Status Indicator (Bubble)
                if (this.expression) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.expression, this.x + this.width / 2, this.y - 12 + this.bobOffset);
                }
            }
        }

        // Obstacle (Wall/Block)
        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.x + 4, this.y + 4, this.width, this.height);

                // Body
                ctx.fillStyle = THEME.obstacle;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Top Highlight
                ctx.fillStyle = THEME.obstacleHighlight;
                ctx.fillRect(this.x, this.y, this.width, 4);
            }
        }

        // Gap (Hole)
        class Gap {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isFilled = false;
            }

            checkFilled(movables) {
                for (let obj of movables) {
                    if (obj.x < this.x + this.width &&
                        obj.x + obj.width > this.x &&
                        obj.y < this.y + this.height &&
                        obj.y + obj.height > this.y) {

                        const overlapWidth = Math.min(obj.x + obj.width, this.x + this.width) - Math.max(obj.x, this.x);
                        const overlapHeight = Math.min(obj.y + obj.height, this.y + this.height) - Math.max(obj.y, this.y);
                        const overlapArea = overlapWidth * overlapHeight;
                        const gapArea = this.width * this.height;
                        const coverageRatio = overlapArea / gapArea;

                        this.coverageRatio = coverageRatio;

                        if (coverageRatio > 0.5) {
                            this.isFilled = true;
                            return;
                        }
                    }
                }
                this.isFilled = false;
                this.coverageRatio = 0;
            }

            draw(ctx) {
                if (!this.isFilled) {
                    // Inner shadow effect
                    ctx.fillStyle = THEME.gap;
                    ctx.fillRect(this.x, this.y, this.width, this.height);

                    // Inner borders to give depth
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(this.x, this.y, this.width, 10); // Top inner shadow
                    ctx.fillRect(this.x, this.y, 10, this.height); // Left inner shadow
                }
            }
        }

        // Movable Object (Plank/Block) - Redesign: Sleek Slider
        class Movable {
            constructor(x, y, width, height, type = 'plank') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.90;
                this.mass = 2;
            }

            applyForce(fx, fy) {
                this.vx += fx / this.mass;
                this.vy += fy / this.mass;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vx *= this.friction;
                this.vy *= this.friction;

                if (Math.abs(this.vx) < 1) this.vx = 0;
                if (Math.abs(this.vy) < 1) this.vy = 0;

                // Limits
                if (this.x < 0) { this.x = 0; this.vx = 0; }
                if (this.x + this.width > GAME_WIDTH) { this.x = GAME_WIDTH - this.width; this.vx = 0; }
                if (this.y < 0) { this.y = 0; this.vy = 0; }
                if (this.y + this.height > GAME_HEIGHT) { this.y = GAME_HEIGHT - this.height; this.vy = 0; }
            }

            draw(ctx) {
                if (this.type === 'plank') {
                    // Sleek Industrial Design

                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    roundRect(ctx, this.x + 4, this.y + 4, this.width, this.height, 4);
                    ctx.fill();

                    // Main Body: Dark Grey
                    ctx.fillStyle = '#333';
                    roundRect(ctx, this.x, this.y, this.width, this.height, 4);
                    ctx.fill();

                    // Accent: Neon Cyan Edge
                    const lineWidth = 4;
                    ctx.fillStyle = '#0ff'; // Neon

                    // Draw accent strip on left
                    ctx.fillRect(this.x + 10, this.y + 10, 5, this.height - 20);

                    // Draw accent strip on right
                    ctx.fillRect(this.x + this.width - 15, this.y + 10, 5, this.height - 20);

                    // Center detail (Grip lines)
                    ctx.fillStyle = '#444';
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 20, 30, 4);
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 30, 30, 4);
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 40, 30, 4);
                }
            }
        }

        // Blockage - Redesign: Geometric Cluster (Shatter Effect)
        class Blockage {
            constructor(x, y, width, height, revealsPath = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.blocked = true;
                this.revealsPath = revealsPath;
                this.opacity = 1.0;

                // Parts for shattered visual
                this.parts = [];
                const cols = 3;
                const rows = 3;
                const partW = width / cols;
                const partH = height / rows;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        this.parts.push({
                            ox: c * partW, // Offset X
                            oy: r * partH, // Offset Y
                            w: partW - 2,  // Gap
                            h: partH - 2,
                            vx: 0,
                            vy: 0,
                            active: true
                        });
                    }
                }
            }

            draw(ctx) {
                if (this.blocked) {
                    // Draw clustered parts
                    ctx.fillStyle = '#C2B280'; // Sand/Stone color
                    // Or maybe a bit more geometric "glitch" color
                    ctx.fillStyle = '#aaa';

                    for (let p of this.parts) {
                        ctx.fillStyle = '#555';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);

                        // Highlight
                        ctx.fillStyle = '#777';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, 4);
                    }

                } else {
                    // Shatter animation
                    if (this.opacity > 0) {
                        this.opacity -= 0.02;

                        for (let p of this.parts) {
                            if (!p.vx) {
                                // Explode outwards
                                p.vx = (Math.random() - 0.5) * 10;
                                p.vy = (Math.random() - 0.5) * 10;
                            }
                            p.ox += p.vx;
                            p.oy += p.vy;

                            ctx.fillStyle = `rgba(150, 150, 150, ${this.opacity})`;
                            ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);
                        }
                    }

                    // Reveal path visual
                    if (this.revealsPath) {
                        const wp = this.revealsPath.waypoint;
                        // Draw Waypoint marker
                        ctx.fillStyle = THEME.exit;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(wp.x, wp.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }

        // Wind System
        class Wind {
            constructor() {
                this.x = GAME_WIDTH / 2;
                this.y = 50;
                this.active = false;
                this.direction = { x: 0, y: 1 };
                this.strength = 150; // Reduced from 300 to 150
                this.size = 30;
                this.timer = 0;
                this.streams = []; // For visual effect
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
            }

            setDirection(key) {
                switch (key) {
                    case 'w': case 'W': this.direction = { x: 0, y: -1 }; break;
                    case 's': case 'S': this.direction = { x: 0, y: 1 }; break;
                    case 'a': case 'A': this.direction = { x: -1, y: 0 }; break;
                    case 'd': case 'D': this.direction = { x: 1, y: 0 }; break;
                }
            }

            activate() {
                this.active = true;
            }

            stop() {
                this.active = false;
            }

            checkBlockages(blockages) {
                if (!this.active) return false;
                const windReach = 200;

                for (let blockage of blockages) {
                    if (!blockage.blocked) continue;

                    const toBlockageX = blockage.x + blockage.width / 2 - this.x;
                    const toBlockageY = blockage.y + blockage.height / 2 - this.y;
                    const distance = Math.sqrt(toBlockageX * toBlockageX + toBlockageY * toBlockageY);

                    if (distance < windReach) {
                        const dot = (toBlockageX * this.direction.x + toBlockageY * this.direction.y) / distance;
                        if (dot > 0.6) {
                            blockage.blocked = false;

                            // Explosion effect
                            particles.spawn(blockage.x + blockage.width / 2, blockage.y + blockage.height / 2, 'dust', 10);
                            return true;
                        }
                    }
                }
                return false;
            }

            pushMovables(movables) {
                if (!this.active) return;
                const windReach = 250;

                for (let obj of movables) {
                    const toObjX = obj.x + obj.width / 2 - this.x;
                    const toObjY = obj.y + obj.height / 2 - this.y;
                    const distance = Math.sqrt(toObjX * toObjX + toObjY * toObjY);

                    if (distance < windReach) {
                        const dot = (toObjX * this.direction.x + toObjY * this.direction.y) / distance;
                        if (dot > 0.5) {
                            const forceMagnitude = this.strength * (1 - distance / windReach);
                            const fx = this.direction.x * forceMagnitude;
                            const fy = this.direction.y * forceMagnitude;
                            obj.applyForce(fx, fy);

                            // Interaction particles
                            if (Math.random() < 0.1) {
                                particles.spawn(obj.x + obj.width / 2, obj.y + obj.height / 2, 'wind');
                            }
                        }
                    }
                }
            }

            draw(ctx) {
                this.timer += 0.1;

                if (this.active) {
                    // Update streams
                    if (Math.random() < 0.3) {
                        this.streams.push({
                            x: this.x + (Math.random() - 0.5) * 40,
                            y: this.y + (Math.random() - 0.5) * 40,
                            len: 0,
                            maxLen: 50 + Math.random() * 100,
                            alpha: 1.0,
                            width: 2 + Math.random() * 3
                        });
                    }
                }

                // Draw streams
                for (let i = this.streams.length - 1; i >= 0; i--) {
                    let s = this.streams[i];
                    s.len += 10;
                    s.alpha -= 0.05;
                    s.x += this.direction.x * 5;
                    s.y += this.direction.y * 5;

                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x + this.direction.x * s.len, s.y + this.direction.y * s.len);
                    ctx.strokeStyle = `rgba(100, 255, 255, ${s.alpha * 0.5})`;
                    ctx.lineWidth = s.width;
                    ctx.stroke();

                    if (s.alpha <= 0) this.streams.splice(i, 1);
                }

                // Cursor visual
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.stroke();

                if (this.active) {
                    // Wind gusts visual (lines)
                    const endX = this.x + this.direction.x * 150;
                    const endY = this.y + this.direction.y * 150;

                    const grad = ctx.createLinearGradient(this.x, this.y, endX, endY);
                    grad.addColorStop(0, 'rgba(100, 255, 255, 0.0)');
                    grad.addColorStop(0.2, 'rgba(100, 255, 255, 0.3)');
                    grad.addColorStop(1, 'rgba(100, 255, 255, 0.0)');

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 40;
                    ctx.lineCap = 'round';
                    // Using a blurred line for "air" feel?
                    // Canvas doesn't support easy blur on stroke without filter
                    // Just accept the gradient for now as a "beam"
                    ctx.stroke();
                }
            }
        }

        // 游戏状态
        let currentLevel = 1;
        let girl = null;
        let obstacles = [];
        let blockages = [];
        let gaps = [];
        let movables = [];
        let wind = new Wind();

        // Helper to get grid position
        function getGridPos(col, row) {
            return {
                x: GRID_OFFSET_X + col * CELL_SIZE,
                y: GRID_OFFSET_Y + row * CELL_SIZE
            };
        }

        // 第一关的布局
        function setupLevel1() {
            obstacles = [];
            blockages = [];
            gaps = [];
            movables = [];

            const startPos = getGridPos(0, 1.5);

            // Fix: Align Start Position to Row 1 exactly to allow walking
            // Girl works best when aligned to grid for simple path finding
            // Center girl on (0, 1) to avoid clipping obstacle at (2, 1)
            let safeStart = getGridPos(0, 1);

            girl = new Girl(safeStart.x + (CELL_SIZE - GIRL_SIZE) / 2, safeStart.y + (CELL_SIZE - GIRL_SIZE) / 2);
            girl.goalX = getGridPos(3, 1).x + (CELL_SIZE - GIRL_SIZE) / 2;
            girl.goalY = getGridPos(3, 1).y + (CELL_SIZE - GIRL_SIZE) / 2;

            // Fix: Set Final Goal explicitly here
            girl.finalGoalX = girl.goalX;
            girl.finalGoalY = girl.goalY;

            girl.currentGoalX = girl.goalX;
            girl.currentGoalY = girl.goalY;

            // Obstacle at (2, 1)
            const obsPos = getGridPos(2, 1);
            obstacles.push(new Obstacle(obsPos.x, obsPos.y, CELL_SIZE, CELL_SIZE));

            // The logic: Girl wants to go (0,1) -> (3,1), blocked by (2,1)
            // She checks for detour.
            // Blockage at (1, 2) hides detour.
            const blockPos = getGridPos(1, 2);

            // Waypoint for detour at (2, 2)
            // Ensure path (1,2) -> (2,2) -> (3,2) -> (3,1) is viable
            // The blockage is at (1,2), so when it opens, she can walk to (2,2).
            const detourWaypoint = getGridPos(2, 2);
            detourWaypoint.x += CELL_SIZE / 2; // Center
            detourWaypoint.y += CELL_SIZE / 2;

            blockages.push(new Blockage(
                blockPos.x, blockPos.y, CELL_SIZE, CELL_SIZE,
                { waypoint: detourWaypoint }
            ));
        }

        // 第二关的布局
        function setupLevel2() {
            obstacles = [];
            blockages = [];
            gaps = [];
            movables = [];

            const startPos = getGridPos(0, 1);
            girl = new Girl(startPos.x + (CELL_SIZE - GIRL_SIZE) / 2, startPos.y + (CELL_SIZE - GIRL_SIZE) / 2);
            girl.goalX = getGridPos(3, 1).x + (CELL_SIZE - GIRL_SIZE) / 2;
            girl.goalY = getGridPos(3, 1).y + (CELL_SIZE - GIRL_SIZE) / 2;
            girl.finalGoalX = girl.goalX;
            girl.finalGoalY = girl.goalY;
            girl.currentGoalX = girl.goalX;
            girl.currentGoalY = girl.goalY;

            // Gap at (2, 1)
            const gapPos = getGridPos(2, 1);
            gaps.push(new Gap(gapPos.x, gapPos.y, CELL_SIZE, CELL_SIZE));

            // Plank available at (1, 2)
            // Fixed: Make plank larger to fit grid
            const plankPos = getGridPos(1, 2);
            movables.push(new Movable(plankPos.x, plankPos.y, CELL_SIZE, CELL_SIZE, 'plank'));
        }

        // 加载关卡
        function loadLevel(level) {
            currentLevel = level;
            levelIndicator.innerText = `LEVEL ${level}`;
            if (level === 1) setupLevel1();
            else if (level === 2) setupLevel2();
        }

        // 初始化
        loadLevel(1);

        // 输入处理
        let mouseX = GAME_WIDTH / 2;
        let mouseY = 50;
        let activeKeys = new Set();

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates if canvas is styled different than logical size
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;
            wind.setPosition(mouseX, mouseY);
        });

        document.addEventListener('keydown', (e) => {
            if (activeKeys.has(e.key.toLowerCase())) return;

            if (['w', 'W', 'a', 'A', 's', 'S', 'd', 'D'].includes(e.key)) {
                e.preventDefault();
                activeKeys.add(e.key.toLowerCase());
                wind.setDirection(e.key);
                wind.activate();
                wind.checkBlockages(blockages);
            } else if (e.key === 'r' || e.key === 'R') {
                loadLevel(currentLevel);
            } else if (e.key === '1') {
                loadLevel(1);
            } else if (e.key === '2') {
                loadLevel(2);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (['w', 'W', 'a', 'A', 's', 'S', 'd', 'D'].includes(e.key)) {
                activeKeys.delete(e.key.toLowerCase());
                if (!activeKeys.has('w') && !activeKeys.has('a') &&
                    !activeKeys.has('s') && !activeKeys.has('d')) {
                    wind.stop();
                }
            }
        });

        // 游戏循环
        let lastTime = Date.now();

        function gameLoop() {
            const now = Date.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            // Updates
            for (let obj of movables) obj.update(dt);
            for (let gap of gaps) gap.checkFilled(movables);
            if (girl) girl.update(dt, obstacles, blockages, gaps);

            if (wind.active) {
                wind.pushMovables(movables);
                wind.checkBlockages(blockages);
            }

            particles.update(dt);

            // Draw
            // 1. Background
            ctx.fillStyle = THEME.bg;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // 2. Draw Grid (Subtle)
            ctx.save();
            ctx.translate(GRID_OFFSET_X, GRID_OFFSET_Y);
            for (let r = 0; r < GRID_H; r++) {
                for (let c = 0; c < GRID_W; c++) {
                    ctx.fillStyle = THEME.grid;
                    // Slightly smaller than cell to leave gaps
                    ctx.fillRect(c * CELL_SIZE + 2, r * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                }
            }
            ctx.restore();

            // 3. Draw Entities

            // Exit Marker (New) - Use FINAL GOAL
            if (girl) {
                // Determine exit position (goal)
                // Draw a glowing floor plate
                ctx.save();
                // Use finalGoalX/Y instead of goalX/Y which changes
                const exitX = girl.finalGoalX + GIRL_SIZE / 2;
                const exitY = girl.finalGoalY + GIRL_SIZE / 2;
                const exitRadius = 30 + Math.sin(now / 500) * 5;

                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.2)'; // Warm Orange/Yellow
                ctx.fill();

                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.4)';
                ctx.fill();

                // Light beam
                const grad = ctx.createLinearGradient(exitX, exitY, exitX, exitY - 100);
                grad.addColorStop(0, 'rgba(255, 170, 51, 0.3)');
                grad.addColorStop(1, 'rgba(255, 170, 51, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(exitX - 20, exitY - 100, 40, 100);

                ctx.restore();
            }

            for (let gap of gaps) gap.draw(ctx);
            for (let obs of obstacles) obs.draw(ctx);
            for (let blockage of blockages) blockage.draw(ctx);
            for (let obj of movables) obj.draw(ctx);
            if (girl) girl.draw(ctx);

            // 4. Draw Particles
            particles.draw(ctx);

            // 5. Draw Wind
            wind.draw(ctx);

            // 6. Lighting / Vignette Overlay
            const gradient = ctx.createRadialGradient(
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 200,
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 500
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            requestAnimationFrame(gameLoop);
        }

        // 启动游戏
        gameLoop();
    </script>
</body>

</html>