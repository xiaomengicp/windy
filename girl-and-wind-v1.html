<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>女孩与风 - 原型v1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ddd;
            height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            background: #1a1b1e;
            display: block;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            pointer-events: none;
            backdrop-filter: blur(5px);
            border-left: 2px solid #ff6b9d;
        }

        .controls div {
            margin-bottom: 5px;
            font-size: 13px;
            color: #aaa;
        }

        .controls strong {
            color: #fff;
            display: block;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            left: 30px;
            font-size: 24px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 2px;
        }

        .debug {
            display: none;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="level-indicator" id="levelIndicator">LEVEL 1</div>
        <div class="controls">
            <div><strong>Controls</strong></div>
            <div>MOUSE - Move Wind Source</div>
            <div>HOLD W/A/S/D - Blow Wind</div>
            <div>R - Restart Level</div>
            <div>1/2 - Switch Level</div>
        </div>
    </div>

    <div class="debug" id="debugInfo"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelIndicator = document.getElementById('levelIndicator');

        // Visual Style Constants
        const THEME = {
            bg: '#1a1b1e',
            grid: '#232428',
            wall: '#2a2b30',
            highlight: '#3a3b40',
            girl: '#ff6b9d',
            girlShadow: '#b03055',
            obstacle: '#333333',
            obstacleHighlight: '#444444',
            plank: '#cba', // Light minimalist wood/block
            plankShadow: '#876',
            wind: '#4ff',
            exit: '#44ffaa',
            gap: '#151619' // Slightly darker than BG
        };

        // Grid System
        const CELL_SIZE = 80;
        const GRID_W = 4;
        const GRID_H = 4;
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;

        // Calculate Grid Offset to center it
        const GRID_OFFSET_X = (GAME_WIDTH - (GRID_W * CELL_SIZE)) / 2;
        const GRID_OFFSET_Y = (GAME_HEIGHT - (GRID_H * CELL_SIZE)) / 2;

        // Configuration
        const GIRL_SIZE = 40; // Smaller relative to cell (half size) for "small" feel
        const GIRL_SPEED = 150; // Adjusted for larger scale


        // Helper for rounded rectangles
        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            return ctx;
        }

        // Particle System
        class Particle {
            constructor(x, y, type = 'dust') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1.0;

                if (type === 'dust') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    this.decay = 0.005 + Math.random() * 0.01;
                    this.size = 1 + Math.random() * 2;
                    this.color = `rgba(255, 255, 255, ${0.05 + Math.random() * 0.1})`;
                } else if (type === 'wind') {
                    this.vx = 0;
                    this.vy = 0;
                    this.decay = 0.02 + Math.random() * 0.03;
                    this.size = 2 + Math.random() * 3;
                    this.color = '#4ff';
                }
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= this.decay;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;

                if (this.type === 'wind') {
                    ctx.fillStyle = THEME.wind;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            spawn(x, y, type, count = 1) {
                for (let i = 0; i < count; i++) {
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    this.particles.push(new Particle(x + offsetX, y + offsetY, type));
                }
            }

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.update(dt);
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }

                // Always spawn background dust
                if (Math.random() < 0.2) {
                    this.spawn(
                        Math.random() * GAME_WIDTH,
                        Math.random() * GAME_HEIGHT,
                        'dust'
                    );
                }
            }

            draw(ctx) {
                for (let p of this.particles) {
                    p.draw(ctx);
                }
            }
        }

        const particles = new ParticleSystem();

        // Girl with "Thomas Was Alone" Aesthetics
        class Girl {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = GIRL_SIZE;
                this.height = GIRL_SIZE;
                this.goalX = GAME_WIDTH - 50;
                this.goalY = GAME_HEIGHT / 2;

                // Final Goal (The Exit) - Persistent
                this.finalGoalX = this.goalX;
                this.finalGoalY = this.goalY;

                // currentGoal is the IMMEDIATE waypoint we are walking towards
                this.currentGoalX = this.goalX;
                this.currentGoalY = this.goalY;

                // Waypoint Queue for L-Shaped movement
                this.pathQueue = [];

                this.state = 'WALKING';
                this.speed = GIRL_SPEED;
                this.color = '#ff6b9d';
                this.stateTimer = 0;

                this.stateTimer = 0;

                this.detourPath = null;
                this.hasDetoured = false; // Flag to prevent re-taking the same detour
                this.reachedWaypoint = false;

                // Animation
                this.bobOffset = 0;
                this.eyeOffset = { x: 0, y: 0 };
                this.blinkTimer = 0;
                this.expression = '';
            }

            update(dt, obstacles, blockages, gaps) {
                // Update animation state
                this.bobOffset = Math.sin(Date.now() / 150) * 2;
                if (Math.random() < 0.01) this.blinkTimer = 10;
                if (this.blinkTimer > 0) this.blinkTimer--;

                // Logic State Machine
                switch (this.state) {
                    case 'WALKING':
                        this.updateWalking(dt, obstacles, gaps);

                        // Spawn trail particles
                        if (Math.random() < 0.1) {
                            particles.spawn(this.x + this.width / 2, this.y + this.height, 'dust');
                        }

                        // Check if we ran into a blockage (collision handled in walking, but this is for specific state trigger)
                        // Actually, updateWalking handles collision by stopping.
                        // We need to check if we are "stuck" or "blocked" by logic, not just physics.
                        // If pathQueue is empty but we haven't reached final goal, we might be blocked.

                        // Check collision with Blockages specifically to trigger "BLOCKED" state
                        for (let b of blockages) {
                            if (b.blocked && this.checkCollision(this.x, this.y, [b], [])) {
                                this.state = 'BLOCKED';
                                this.stateTimer = 0;
                                this.expression = '!';
                                // Bounce back a bit
                                this.x -= Math.sign(this.currentGoalX - this.x) * 5;
                                this.y -= Math.sign(this.currentGoalY - this.y) * 5;
                                this.pathQueue = []; // Clear path
                            }
                        }
                        break;

                    case 'BLOCKED':
                        // 1. Bounce -> Stop
                        // 2. Expression '?'
                        this.stateTimer += dt;
                        this.expression = '?';
                        if (this.stateTimer > 1.0) {
                            this.state = 'TRY_PUSH';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'TRY_PUSH':
                        // 3. Expression '>' (Trying to move forward)
                        this.expression = '>';
                        this.stateTimer += dt;

                        // Small "pushing" animation
                        this.x += (Math.random() - 0.5) * 1;
                        this.y += (Math.random() - 0.5) * 1;

                        if (this.stateTimer > 0.8) {
                            this.state = 'THINKING';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'STOPPED':
                        // Generic stop from collision or just idle
                        this.stateTimer += dt;
                        this.expression = '?';
                        if (this.stateTimer > 1.0) {
                            this.state = 'TRY_PUSH';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'THINKING':
                        this.stateTimer += dt;
                        this.expression = '...';

                        // Check for world changes (detours opened, gaps filled)
                        if (this.checkEnvironment(blockages, gaps)) {
                            // EVENT: Path Cleared
                            this.state = 'HESITATE';
                            this.stateTimer = 0;
                            this.expression = '!'; // Idea!
                        } else {
                            // If no solution found, keep thinking or retry walking random?
                            // Loop back to Trying to Push or just stay Thinking
                            if (this.stateTimer > 2.0) {
                                this.state = 'STOPPED'; // Loop back
                                this.stateTimer = 0;
                            }
                        }
                        break;

                    case 'HESITATE':
                        // 5. Hesitate '!'
                        this.stateTimer += dt;
                        this.expression = '!';
                        if (this.stateTimer > 0.8) {
                            this.state = 'ASSESS';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'ASSESS':
                        // 6. Assess '...'
                        this.stateTimer += dt;
                        this.expression = '...';
                        if (this.stateTimer > 1.0) {
                            this.state = 'WALKING';
                            this.expression = '';
                        }
                        break;

                    case 'REACHED_GOAL':
                        this.expression = '♥';
                        break;
                }

                // Always try to plan path if walking
                if (this.state === 'WALKING') {
                    this.planPath(obstacles, blockages);
                }

                // Detour Completion Logic
                if (this.detourPath) {
                    // Check if reached waypoint (currentGoal/goal)
                    // If pathQueue is empty and we are close to goal
                    if (this.pathQueue.length === 0 && Math.abs(this.x - this.goalX) < 10 && Math.abs(this.y - this.goalY) < 10) {
                        this.reachedWaypoint = true;

                        // Fix: Back to Final Goal
                        this.goalX = this.finalGoalX;
                        this.goalY = this.finalGoalY;
                        this.currentGoalX = this.finalGoalX;
                        this.currentGoalY = this.finalGoalY;

                        this.pathQueue = []; // Force recalc path to final goal
                        this.detourPath = null;
                        this.state = 'WALKING'; // Ensure we keep walking
                        this.hasDetoured = true; // Mark as done so we don't go back
                    }
                }
            }

            checkEnvironment(blockages, gaps) {
                // Generic Check: Can I reach my current goal?
                // Or better: Can I reach my FINAL goal?

                // If I am detour-ing, I am already happy. 
                // But if I am BLOCKED/THINKING, I am waiting for something to change.

                // 1. Check if direct path to Current Goal is possible?
                if (this.canReachGoal(this.currentGoalX, this.currentGoalY, obstacles, blockages, gaps)) {
                    // But wait, if direct path was blocked by DETOUR wall, we need to know.
                    return true;
                }

                // 2. If impossible, check if DETOUR is now an option?
                // (Only for Level 2 logic, but let's make it generic)
                // If any blockage revealing a path is now unblocked?
                const detourBlock = blockages.find(b => b.revealsPath && !b.blocked);
                if (detourBlock && !this.hasDetoured) {
                    if (this.goalX !== detourBlock.revealsPath.waypoint.x) {
                        // Switch goal to detour!
                        this.goalX = detourBlock.revealsPath.waypoint.x;
                        this.goalY = detourBlock.revealsPath.waypoint.y;
                        this.currentGoalX = this.goalX;
                        this.currentGoalY = this.goalY;
                        this.pathQueue = [];
                        this.detourPath = true;
                        return true;
                    }
                }

                return false;
            }

            canReachGoal(tx, ty, obstacles, blockages, gaps) {
                // Simple check: Can I make an L-shaped path without collision?
                // This effectively dry-runs 'generatePath'.

                // Treat active blockages as obstacles
                const activeObstacles = [...obstacles];
                for (let b of blockages) {
                    if (b.blocked) {
                        activeObstacles.push({ x: b.x, y: b.y, width: b.width, height: b.height });
                    }
                }

                // Dry run generating path
                // Option A: X then Y
                let firstPointA = { x: tx, y: this.y };
                // Check segment 1: Current -> FirstPointA
                let safeA1 = !this.checkCollisionLine(this.x, this.y, firstPointA.x, firstPointA.y, activeObstacles, gaps);
                // Check segment 2: FirstPointA -> Target
                let safeA2 = !this.checkCollisionLine(firstPointA.x, firstPointA.y, tx, ty, activeObstacles, gaps);

                if (safeA1 && safeA2) return true;

                // Option B: Y then X
                let firstPointB = { x: this.x, y: ty };
                let safeB1 = !this.checkCollisionLine(this.x, this.y, firstPointB.x, firstPointB.y, activeObstacles, gaps);
                let safeB2 = !this.checkCollisionLine(firstPointB.x, firstPointB.y, tx, ty, activeObstacles, gaps);

                return safeB1 && safeB2;
            }

            checkCollisionLine(x1, y1, x2, y2, obstacles, gaps) {
                // Simplified line check: Check start, end, and midpoint? 
                // Since movements are axis aligned, we just check the rect formed by the line.
                // Or better, use checkCollision on a few points?
                // For this grid/AI, checking the End Point of the segment is often mostly sufficient if grid aligned.
                // But let's be safer: Check the full "Swept" rect.

                const minX = Math.min(x1, x2);
                const maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2);
                const maxY = Math.max(y1, y2);
                const width = (maxX - minX) + this.width; // Girl dim
                const height = (maxY - minY) + this.height;

                // Effective rect for collision
                const rectX = minX; // technically should account for girl center/origin logic, but collision uses top-left
                const rectY = minY;

                // Just use existing checkCollision on the end point? 
                // No, that misses walls in between.

                // Let's iterate obstacles and checks intersection with the movement segment.
                // Since AABB:
                for (let obs of obstacles) {
                    if (maxX + this.width > obs.x &&
                        minX < obs.x + obs.width &&
                        maxY + this.height > obs.y &&
                        minY < obs.y + obs.height) {
                        return true;
                    }
                }

                // Gaps logic (must be filled)
                for (let gap of gaps) {
                    if (!gap.isFilled) {
                        if (maxX + this.width > gap.x &&
                            minX < gap.x + gap.width &&
                            maxY + this.height > gap.y &&
                            minY < gap.y + gap.height) {
                            return true;
                        }
                    }
                }

                return false;
            }
            planPath(obstacles, blockages) {
                // Determine high-level Goal (Final destination or Detour)
                // If we have a detour and haven't reached it, target detour.
                let finalTargetX = this.goalX;
                let finalTargetY = this.goalY;

                // Check if direct path is blocked by a Blockage entity
                // If so, look for detour
                // This is specific "AI" logic for the level
                if (currentLevel === 1) {
                    const mainBlockage = obstacles.find(o => o.y === this.y || Math.abs(o.y - this.y) < 10);
                    // Actually, let's keep it simple:
                    // If we are at the detour start (Logic handled in updateWalking to trigger detour)
                }

                // If queue is empty, we need to generate a path to finalTarget
                if (this.pathQueue.length === 0 && (Math.abs(this.x - finalTargetX) > 5 || Math.abs(this.y - finalTargetY) > 5)) {
                    // Generate L-shaped path
                    this.generatePath(finalTargetX, finalTargetY, obstacles);
                }
            }

            generatePath(tx, ty, obstacles) {
                // Simple L-shape generator:
                // Option A: X then Y
                // Option B: Y then X
                // Check which one is valid (no obstacles)

                let pathA = [
                    { x: tx, y: this.y }, // Intermediate (move X, same Y)
                    { x: tx, y: ty }      // Final
                ];

                let pathB = [
                    { x: this.x, y: ty }, // Intermediate (move Y, same X)
                    { x: tx, y: ty }      // Final
                ];

                // Validate Path A (Check segment from Current to Inter, and Inter to Final)
                // Simplification: Check intermediate point collision? No, need line check.
                // For grid-like game, checking the corners/intermediate box is usually enough.

                /* 
                   We want to find a path that doesn't collide.
                   Let's prioritize: Go X if |dx| > |dy| (unless blocked).
                 */

                const dx = tx - this.x;
                const dy = ty - this.y;

                // If already aligned on one axis, just push final
                if (Math.abs(dx) < 5 || Math.abs(dy) < 5) {
                    this.pathQueue = [{ x: tx, y: ty }];
                    return;
                }

                // Default: Try X then Y
                let firstPoint = { x: tx, y: this.y };
                // Check if `firstPoint` is safe (and the path to it)
                if (!this.checkCollision(firstPoint.x, firstPoint.y, obstacles, [])) {
                    this.pathQueue = [firstPoint, { x: tx, y: ty }];
                } else {
                    // Try Y then X
                    this.pathQueue = [{ x: this.x, y: ty }, { x: tx, y: ty }];
                }
            }

            updateWalking(dt, obstacles, gaps) {
                // Consume Queue

                if (this.pathQueue.length === 0) return;

                const target = this.pathQueue[0];
                this.currentGoalX = target.x;
                this.currentGoalY = target.y;

                const dx = this.currentGoalX - this.x;
                const dy = this.currentGoalY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 5) {
                    // Reached waypoint
                    this.x = this.currentGoalX;
                    this.y = this.currentGoalY;
                    this.pathQueue.shift(); // Remove reached waypoint
                    return;
                }

                // Move towards current waypoint (Strictly on axis usually, but since we decomposed to L-shape, 
                // one of dx/dy should be ~0. If floating point mess, we force it.)

                let moveX = 0;
                let moveY = 0;

                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = Math.sign(dx) * this.speed * dt;
                } else {
                    moveY = Math.sign(dy) * this.speed * dt;
                }

                const nextX = this.x + moveX;
                const nextY = this.y + moveY;

                if (!this.checkCollision(nextX, nextY, obstacles, gaps)) {
                    this.x = nextX;
                    this.y = nextY;
                } else {
                    // Bonk
                    this.state = 'STOPPED';
                    this.stateTimer = 0;
                    // Clear queue to recalc options?
                    this.pathQueue = [];
                }
            }

            checkCollision(x, y, obstacles, gaps) {
                // ... existing collision logic ...
                // Need to use temporary rect
                // Girl is GIRL_SIZE (40)
                for (let obs of obstacles) {
                    if (x < obs.x + obs.width &&
                        x + this.width > obs.x &&
                        y < obs.y + obs.height &&
                        y + this.height > obs.y) {
                        return true;
                    }
                }

                // Gaps logic (only if not filled)
                for (let gap of gaps) {
                    if (!gap.isFilled &&
                        x < gap.x + gap.width &&
                        x + this.width > gap.x &&
                        y < gap.y + gap.height &&
                        y + this.height > gap.y) {

                        // Check strict overlap (center point?)
                        // If center of girl is inside gap
                        const cx = x + this.width / 2;
                        const cy = y + this.height / 2;
                        if (cx > gap.x && cx < gap.x + gap.width &&
                            cy > gap.y && cy < gap.y + gap.height) {
                            return true; // Fall in gap
                        }
                    }
                }
                return false;
            }

            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                roundRect(ctx, this.x + 5, this.y + 5 + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Body
                ctx.fillStyle = THEME.girl;
                roundRect(ctx, this.x, this.y + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Inner Highlights (Bevel effect)
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(this.x, this.y + this.bobOffset, this.width, 4);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(this.x, this.y + this.height - 4 + this.bobOffset, this.width, 4);

                // Expressions (Eyes)
                ctx.fillStyle = '#fff';
                const eyeY = this.y + this.height / 3 + this.bobOffset;

                // Normal Eyes
                let leftEyeX = this.x + 10 + this.eyeOffset.x;
                let rightEyeX = this.x + this.width - 14 + this.eyeOffset.x;
                let eyeH = 8;

                if (this.blinkTimer > 0) {
                    eyeH = 2; // Blinking
                }

                // Draw Eyes
                if (this.state !== 'REACHED_GOAL') {
                    ctx.fillRect(leftEyeX, eyeY, 4, eyeH);
                    ctx.fillRect(rightEyeX, eyeY, 4, eyeH);
                } else {
                    // Happy eyes ^ ^
                    ctx.beginPath();
                    ctx.moveTo(leftEyeX - 2, eyeY + 4);
                    ctx.lineTo(leftEyeX + 2, eyeY);
                    ctx.lineTo(leftEyeX + 6, eyeY + 4);

                    ctx.moveTo(rightEyeX - 2, eyeY + 4);
                    ctx.lineTo(rightEyeX + 2, eyeY);
                    ctx.lineTo(rightEyeX + 6, eyeY + 4);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Status Indicator (Bubble)
                if (this.expression) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.expression, this.x + this.width / 2, this.y - 12 + this.bobOffset);
                }
            }
        }

        // Obstacle (Wall/Block)
        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.x + 4, this.y + 4, this.width, this.height);

                // Body
                ctx.fillStyle = THEME.obstacle;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Top Highlight
                ctx.fillStyle = THEME.obstacleHighlight;
                ctx.fillRect(this.x, this.y, this.width, 4);
            }
        }

        // Gap (Hole)
        class Gap {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isFilled = false;
            }

            checkFilled(movables) {
                for (let obj of movables) {
                    if (obj.x < this.x + this.width &&
                        obj.x + obj.width > this.x &&
                        obj.y < this.y + this.height &&
                        obj.y + obj.height > this.y) {

                        const overlapWidth = Math.min(obj.x + obj.width, this.x + this.width) - Math.max(obj.x, this.x);
                        const overlapHeight = Math.min(obj.y + obj.height, this.y + this.height) - Math.max(obj.y, this.y);
                        const overlapArea = overlapWidth * overlapHeight;
                        const gapArea = this.width * this.height;
                        const coverageRatio = overlapArea / gapArea;

                        this.coverageRatio = coverageRatio;

                        if (coverageRatio > 0.5) {
                            this.isFilled = true;
                            return;
                        }
                    }
                }
                this.isFilled = false;
                this.coverageRatio = 0;
            }

            draw(ctx) {
                if (!this.isFilled) {
                    // Inner shadow effect
                    ctx.fillStyle = THEME.gap;
                    ctx.fillRect(this.x, this.y, this.width, this.height);

                    // Inner borders to give depth
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(this.x, this.y, this.width, 10); // Top inner shadow
                    ctx.fillRect(this.x, this.y, 10, this.height); // Left inner shadow
                }
            }
        }

        // Movable Object (Plank/Block) - Redesign: Sleek Slider
        class Movable {
            constructor(x, y, width, height, type = 'plank') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.90;
                this.mass = 2;
            }

            applyForce(fx, fy) {
                this.vx += fx / this.mass;
                this.vy += fy / this.mass;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vx *= this.friction;
                this.vy *= this.friction;

                if (Math.abs(this.vx) < 1) this.vx = 0;
                if (Math.abs(this.vy) < 1) this.vy = 0;

                // Limits
                if (this.x < 0) { this.x = 0; this.vx = 0; }
                if (this.x + this.width > GAME_WIDTH) { this.x = GAME_WIDTH - this.width; this.vx = 0; }
                if (this.y < 0) { this.y = 0; this.vy = 0; }
                if (this.y + this.height > GAME_HEIGHT) { this.y = GAME_HEIGHT - this.height; this.vy = 0; }
            }

            draw(ctx) {
                if (this.type === 'plank') {
                    // Sleek Industrial Design

                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    roundRect(ctx, this.x + 4, this.y + 4, this.width, this.height, 4);
                    ctx.fill();

                    // Main Body: Dark Grey
                    ctx.fillStyle = '#333';
                    roundRect(ctx, this.x, this.y, this.width, this.height, 4);
                    ctx.fill();

                    // Accent: Neon Cyan Edge
                    const lineWidth = 4;
                    ctx.fillStyle = '#0ff'; // Neon

                    // Draw accent strip on left
                    ctx.fillRect(this.x + 10, this.y + 10, 5, this.height - 20);

                    // Draw accent strip on right
                    ctx.fillRect(this.x + this.width - 15, this.y + 10, 5, this.height - 20);

                    // Center detail (Grip lines)
                    ctx.fillStyle = '#444';
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 20, 30, 4);
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 30, 30, 4);
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 40, 30, 4);
                }
            }
        }

        // Blockage - Redesign: Geometric Cluster (Shatter Effect)
        class Blockage {
            constructor(x, y, width, height, revealsPath = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.blocked = true;
                this.revealsPath = revealsPath;
                this.opacity = 1.0;

                // Parts for shattered visual
                this.parts = [];
                const cols = 3;
                const rows = 3;
                const partW = width / cols;
                const partH = height / rows;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        this.parts.push({
                            ox: c * partW, // Offset X
                            oy: r * partH, // Offset Y
                            w: partW - 2,  // Gap
                            h: partH - 2,
                            vx: 0,
                            vy: 0,
                            active: true
                        });
                    }
                }
            }

            draw(ctx) {
                if (this.blocked) {
                    // Draw clustered parts
                    ctx.fillStyle = '#C2B280'; // Sand/Stone color
                    // Or maybe a bit more geometric "glitch" color
                    ctx.fillStyle = '#aaa';

                    for (let p of this.parts) {
                        ctx.fillStyle = '#555';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);

                        // Highlight
                        ctx.fillStyle = '#777';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, 4);
                    }

                } else {
                    // Shatter animation
                    if (this.opacity > 0) {
                        this.opacity -= 0.02;

                        for (let p of this.parts) {
                            if (!p.vx) {
                                // Explode outwards
                                p.vx = (Math.random() - 0.5) * 10;
                                p.vy = (Math.random() - 0.5) * 10;
                            }
                            p.ox += p.vx;
                            p.oy += p.vy;

                            ctx.fillStyle = `rgba(150, 150, 150, ${this.opacity})`;
                            ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);
                        }
                    }

                    // Reveal path visual
                    if (this.revealsPath) {
                        const wp = this.revealsPath.waypoint;
                        // Draw Waypoint marker
                        ctx.fillStyle = THEME.exit;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(wp.x, wp.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }

        // Wind System
        class Wind {
            constructor() {
                this.x = GAME_WIDTH / 2;
                this.y = 50;
                this.active = false;
                this.direction = { x: 0, y: 1 };
                this.strength = 150; // Reduced from 300 to 150
                this.size = 30;
                this.timer = 0;
                this.streams = []; // For visual effect
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
            }

            setDirection(key) {
                switch (key) {
                    case 'w': case 'W': this.direction = { x: 0, y: -1 }; break;
                    case 's': case 'S': this.direction = { x: 0, y: 1 }; break;
                    case 'a': case 'A': this.direction = { x: -1, y: 0 }; break;
                    case 'd': case 'D': this.direction = { x: 1, y: 0 }; break;
                }
            }

            activate() {
                this.active = true;
            }

            stop() {
                this.active = false;
            }

            checkBlockages(blockages) {
                if (!this.active) return false;
                const windReach = 200;

                for (let blockage of blockages) {
                    if (!blockage.blocked) continue;

                    const toBlockageX = blockage.x + blockage.width / 2 - this.x;
                    const toBlockageY = blockage.y + blockage.height / 2 - this.y;
                    const distance = Math.sqrt(toBlockageX * toBlockageX + toBlockageY * toBlockageY);

                    if (distance < windReach) {
                        const dot = (toBlockageX * this.direction.x + toBlockageY * this.direction.y) / distance;
                        if (dot > 0.6) {
                            blockage.blocked = false;

                            // Explosion effect
                            particles.spawn(blockage.x + blockage.width / 2, blockage.y + blockage.height / 2, 'dust', 10);
                            return true;
                        }
                    }
                }
                return false;
            }

            pushMovables(movables) {
                if (!this.active) return;
                const windReach = 250;

                for (let obj of movables) {
                    const toObjX = obj.x + obj.width / 2 - this.x;
                    const toObjY = obj.y + obj.height / 2 - this.y;
                    const distance = Math.sqrt(toObjX * toObjX + toObjY * toObjY);

                    if (distance < windReach) {
                        const dot = (toObjX * this.direction.x + toObjY * this.direction.y) / distance;
                        if (dot > 0.5) {
                            const forceMagnitude = this.strength * (1 - distance / windReach);
                            const fx = this.direction.x * forceMagnitude;
                            const fy = this.direction.y * forceMagnitude;
                            obj.applyForce(fx, fy);

                            // Interaction particles
                            if (Math.random() < 0.1) {
                                particles.spawn(obj.x + Math.random() * obj.width, obj.y + Math.random() * obj.height, 'dust', 1);
                            }
                        }
                    }
                }
            }

            checkSwitches(switches) {
                if (!this.active) return;
                for (let s of switches) {
                    const dx = this.x - (s.x + s.width / 2);
                    const dy = this.y - (s.y + s.height / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.size + s.width / 2) {
                        if (!s.active) {
                            s.active = true;
                            // Trigger logic handled in game loop or switch update
                        }
                    }
                }
            }

            draw(ctx) {
                this.timer += 0.1;

                if (this.active) {
                    // Update streams
                    if (Math.random() < 0.3) {
                        this.streams.push({
                            x: this.x + (Math.random() - 0.5) * 40,
                            y: this.y + (Math.random() - 0.5) * 40,
                            len: 0,
                            maxLen: 50 + Math.random() * 100,
                            alpha: 1.0,
                            width: 2 + Math.random() * 3
                        });
                    }
                }

                // Draw streams
                for (let i = this.streams.length - 1; i >= 0; i--) {
                    let s = this.streams[i];
                    s.len += 10;
                    s.alpha -= 0.05;
                    s.x += this.direction.x * 5;
                    s.y += this.direction.y * 5;

                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x + this.direction.x * s.len, s.y + this.direction.y * s.len);
                    ctx.strokeStyle = `rgba(100, 255, 255, ${s.alpha * 0.5})`;
                    ctx.lineWidth = s.width;
                    ctx.stroke();

                    if (s.alpha <= 0) this.streams.splice(i, 1);
                }

                // Cursor visual
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.stroke();

                if (this.active) {
                    // Wind gusts visual (lines)
                    const endX = this.x + this.direction.x * 150;
                    const endY = this.y + this.direction.y * 150;

                    const grad = ctx.createLinearGradient(this.x, this.y, endX, endY);
                    grad.addColorStop(0, 'rgba(100, 255, 255, 0.0)');
                    grad.addColorStop(0.2, 'rgba(100, 255, 255, 0.3)');
                    grad.addColorStop(1, 'rgba(100, 255, 255, 0.0)');

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 40;
                    ctx.lineCap = 'round';
                    // Using a blurred line for "air" feel?
                    // Canvas doesn't support easy blur on stroke without filter
                    // Just accept the gradient for now as a "beam"
                    ctx.stroke();
                }
            }
        }

        // Regenerating Blockage (Grows back)
        class RegeneratingBlockage extends Blockage {
            constructor(x, y, width, height, revealsPath = null) {
                super(x, y, width, height, revealsPath);
                this.regenTime = 5.0; // Seconds to regenerate
                this.regenTimer = 0;
                this.isRegenerating = false;
            }

            update(dt) {
                super.update(dt);
                if (!this.blocked) {
                    this.regenTimer += dt;
                    if (this.regenTimer > this.regenTime) {
                        // Regenerate!
                        this.blocked = true;
                        this.health = 100;
                        this.regenTimer = 0;
                        this.shatterParticles = []; // Reset particles
                    }
                }
            }

            draw(ctx) {
                super.draw(ctx);

                // Draw regeneration indicator (if clearing)
                if (!this.blocked) {
                    const progress = this.regenTimer / this.regenTime;
                    ctx.save();
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.2;
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(this.x + 10, this.y + 10, this.width - 20, this.height - 20);

                    // Progress bar or growing ghost
                    ctx.fillStyle = 'rgba(255, 68, 68, 0.1)';
                    ctx.fillRect(this.x, this.y + this.height * (1 - progress), this.width, this.height * progress);
                    ctx.restore();
                }
            }
        }

        // Wind Switch (Trigger)
        class WindSwitch {
            constructor(x, y, width, height, targetId = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.active = false;
                this.targetId = targetId; // ID of object this switch controls (e.g. a door)
                this.spin = 0;
            }

            update(dt) {
                if (this.active) {
                    this.spin += dt * 10;
                    if (this.spin > Math.PI * 2) this.spin -= Math.PI * 2;
                }
            }

            draw(ctx) {
                // Base
                ctx.fillStyle = '#444';
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Sensor / Fan
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                if (this.active) {
                    ctx.rotate(this.spin);
                    ctx.fillStyle = '#0ff'; // Bright Cyan
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0ff';
                } else {
                    ctx.fillStyle = '#555'; // Inactive
                    // Slow idle spin
                    ctx.rotate(Date.now() / 1000);
                }

                // Draw simple fan blades
                ctx.fillRect(-15, -4, 30, 8);
                ctx.fillRect(-4, -15, 8, 30);

                // Center hub
                ctx.fillStyle = this.active ? '#fff' : '#888';
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Border
                ctx.strokeStyle = this.active ? '#fff' : '#888';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }

        // --- LEVEL SYSTEM ---
        const LEVELS = [
            // Level 1: Tutorial (Hidden Exit, Simple Regenerating Block)
            {
                id: 1,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [],
                blockages: [
                    // Simple block hiding the exit
                    { col: 2, row: 1, type: 'regen', revealsPath: null }
                ],
                movables: [],
                gaps: []
            },

            // Level 2: The Detour (Old Level 1)
            {
                id: 2,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [
                    { col: 2, row: 1 } // Blocks direct path
                ],
                blockages: [
                    // Hides detour
                    {
                        col: 1, row: 2, type: 'static', revealsPath: {
                            waypoint: { col: 2, row: 2 }
                        }
                    }
                ],
                movables: [],
                gaps: []
            },

            // Level 3: Movable Plank (Old Level 2)
            {
                id: 3,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [],
                blockages: [],
                gaps: [
                    { col: 2, row: 1 }
                ],
                movables: [
                    { col: 1, row: 2, type: 'plank' }
                ]
            },

            // Level 4: The Switch
            {
                id: 4,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [],
                blockages: [
                    // Blockage with ID 1
                    { col: 2, row: 1, type: 'static', id: 1 }
                ],
                gaps: [],
                movables: [],
                switches: [
                    { col: 2, row: 2, targetId: 1 }
                ]
            }
        ];

        // 游戏状态
        let currentLevelIndex = 0; // 0-based index for LEVELS array
        let girl = null;
        let obstacles = [];
        let blockages = [];
        let gaps = [];
        let movables = [];
        let switches = []; // New
        let wind = new Wind();

        // Helper to get grid position
        function getGridPos(col, row) {
            return {
                x: GRID_OFFSET_X + col * CELL_SIZE,
                y: GRID_OFFSET_Y + row * CELL_SIZE
            };
        }

        // Helper to parse grid config
        function parseGrid(config) {
            if (!config) return null;
            return getGridPos(config.col, config.row);
        }

        function loadLevel(levelId) {
            const levelData = LEVELS.find(l => l.id === levelId);
            if (!levelData) return;

            currentLevel = levelId;
            levelIndicator.innerText = "LEVEL " + levelId;

            obstacles = [];
            blockages = [];
            gaps = [];
            movables = [];
            switches = [];

            // Setup obstacles
            if (levelData.obstacles) {
                levelData.obstacles.forEach(obs => {
                    const pos = getGridPos(obs.col, obs.row);
                    obstacles.push(new Obstacle(pos.x, pos.y, CELL_SIZE, CELL_SIZE));
                });
            }

            // Setup blockages
            if (levelData.blockages) {
                levelData.blockages.forEach(blk => {
                    const pos = getGridPos(blk.col, blk.row);
                    let reveals = null;
                    if (blk.revealsPath) {
                        // Calculate waypoint center
                        const wp = getGridPos(blk.revealsPath.waypoint.col, blk.revealsPath.waypoint.row);
                        reveals = { waypoint: { x: wp.x + CELL_SIZE / 2, y: wp.y + CELL_SIZE / 2 } };
                    }

                    if (blk.type === 'regen') {
                        blockages.push(new RegeneratingBlockage(pos.x, pos.y, CELL_SIZE, CELL_SIZE, reveals));
                    } else {
                        const b = new Blockage(pos.x, pos.y, CELL_SIZE, CELL_SIZE, reveals);
                        if (blk.id) b.id = blk.id; // Assign ID for switches
                        blockages.push(b);
                    }
                });
            }

            // Setup gaps
            if (levelData.gaps) {
                levelData.gaps.forEach(gap => {
                    const pos = getGridPos(gap.col, gap.row);
                    gaps.push(new Gap(pos.x, pos.y, CELL_SIZE, CELL_SIZE));
                });
            }

            // Setup movables
            if (levelData.movables) {
                levelData.movables.forEach(mov => {
                    const pos = getGridPos(mov.col, mov.row);
                    let w = CELL_SIZE;
                    let h = CELL_SIZE;
                    movables.push(new Movable(pos.x, pos.y, w, h, mov.type));
                });
            }

            // Setup switches
            if (levelData.switches) {
                levelData.switches.forEach(sw => {
                    const pos = getGridPos(sw.col, sw.row);
                    switches.push(new WindSwitch(pos.x, pos.y, CELL_SIZE, CELL_SIZE, sw.targetId));
                });
            }

            // Setup Girl
            const startPos = getGridPos(levelData.gridStart.col, levelData.gridStart.row);
            const goalPos = getGridPos(levelData.gridExit.col, levelData.gridExit.row);

            girl = new Girl(startPos.x + (CELL_SIZE - GIRL_SIZE) / 2, startPos.y + (CELL_SIZE - GIRL_SIZE) / 2);
            girl.goalX = goalPos.x + (CELL_SIZE - GIRL_SIZE) / 2;
            girl.goalY = goalPos.y + (CELL_SIZE - GIRL_SIZE) / 2;
            girl.finalGoalX = girl.goalX;
            girl.finalGoalY = girl.goalY;
            girl.currentGoalX = girl.goalX;
            girl.currentGoalY = girl.goalY;
        }

        // Input Handling

        // Track active wind keys
        const activeKeys = new Set();

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            // Level Controls
            if (key === 'r') {
                loadLevel(currentLevel);
                return;
            }
            if (key >= '1' && key <= '9') {
                const id = parseInt(key);
                if (LEVELS.find(l => l.id === id)) loadLevel(id);
                return;
            }

            // Wind Controls (WASD)
            if (['w', 'a', 's', 'd'].includes(key)) {
                if (!activeKeys.has(key)) {
                    activeKeys.add(key);
                    wind.setDirection(key);
                    wind.activate();
                    wind.checkBlockages(blockages);
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();

            if (['w', 'a', 's', 'd'].includes(key)) {
                activeKeys.delete(key);
                if (activeKeys.size === 0) {
                    wind.stop();
                } else {
                    // Update direction to remaining key (optional, simplistic)
                    const lastKey = Array.from(activeKeys).pop();
                    wind.setDirection(lastKey);
                }
            }
        });

        // Mouse Move
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let mouseX = (e.clientX - rect.left) * scaleX;
            let mouseY = (e.clientY - rect.top) * scaleY;
            wind.setPosition(mouseX, mouseY);
        });

        // Initialize
        loadLevel(1);
        requestAnimationFrame(gameLoop);

        // 游戏循环
        let lastTime = Date.now();

        function gameLoop() {
            const now = Date.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            // Updates
            for (let obj of movables) obj.update(dt);
            for (let s of switches) {
                s.update(dt);
                // Link logic
                if (s.active && s.targetId) {
                    const target = blockages.find(b => b.id === s.targetId);
                    if (target) target.blocked = false; // Open!
                }
            }
            for (let gap of gaps) gap.checkFilled(movables);
            if (girl) girl.update(dt, obstacles, blockages, gaps);

            if (wind.active) {
                wind.pushMovables(movables);
                wind.checkBlockages(blockages);
                wind.checkSwitches(switches);
            }

            particles.update(dt);

            // Draw
            // 1. Background
            ctx.fillStyle = THEME.bg;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // 2. Draw Grid (Subtle)
            ctx.save();
            ctx.translate(GRID_OFFSET_X, GRID_OFFSET_Y);
            for (let r = 0; r < GRID_H; r++) {
                for (let c = 0; c < GRID_W; c++) {
                    ctx.fillStyle = THEME.grid;
                    ctx.fillRect(c * CELL_SIZE + 1, r * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                }
            }
            ctx.restore();

            // 3. Draw Entities

            // Exit Marker (New) - Use FINAL GOAL
            if (girl) {
                // Determine exit position (goal)
                // Draw a glowing floor plate
                ctx.save();
                // Use finalGoalX/Y instead of goalX/Y which changes
                const exitX = girl.finalGoalX + GIRL_SIZE / 2;
                const exitY = girl.finalGoalY + GIRL_SIZE / 2;
                const exitRadius = 30 + Math.sin(now / 500) * 5;

                // Outer Glow
                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.2)'; // Warm Orange/Yellow
                ctx.fill();

                // Inner Core (Restored)
                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.4)';
                ctx.fill();

                // Light Beam (Restored Gradient)
                const grad = ctx.createLinearGradient(exitX, exitY, exitX, exitY - 150);
                grad.addColorStop(0, 'rgba(255, 170, 51, 0.3)');
                grad.addColorStop(1, 'rgba(255, 170, 51, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(exitX - 20, exitY);
                ctx.lineTo(exitX + 20, exitY);
                ctx.lineTo(exitX + 30, exitY - 150);
                ctx.lineTo(exitX - 30, exitY - 150);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }

            for (let gap of gaps) gap.draw(ctx);
            for (let obs of obstacles) obs.draw(ctx);
            for (let blk of blockages) blk.draw(ctx);
            for (let mov of movables) mov.draw(ctx);
            for (let sw of switches) sw.draw(ctx); // Draw switches

            if (girl) girl.draw(ctx);
            wind.draw(ctx);
            particles.draw(ctx);

            // 6. Lighting / Vignette Overlay
            const gradient = ctx.createRadialGradient(
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 200,
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 500
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            requestAnimationFrame(gameLoop);
        }

        // 启动游戏
        gameLoop();
    </script>
</body>

</html>