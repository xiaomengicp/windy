<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Â•≥Â≠©‰∏éÈ£é - ÂéüÂûãv1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ddd;
            height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            background: #1a1b1e;
            display: block;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            pointer-events: none;
            backdrop-filter: blur(5px);
            border-left: 2px solid #ff6b9d;
        }

        .controls div {
            margin-bottom: 5px;
            font-size: 13px;
            color: #aaa;
        }

        .controls strong {
            color: #fff;
            display: block;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            left: 30px;
            font-size: 24px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 2px;
        }

        .debug {
            display: none;
        }

        /* UI OVERLAYS */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Let clicks pass to canvas by default */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            pointer-events: auto;
            /* Catch clicks */
            opacity: 0;
            transition: opacity 0.5s;
            visibility: hidden;
        }

        .screen.active {
            opacity: 1;
            visibility: visible;
        }

        h1 {
            font-size: 64px;
            font-weight: 200;
            letter-spacing: 8px;
            color: #fff;
            margin-bottom: 40px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px 40px;
            font-size: 18px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px;
            letter-spacing: 2px;
            font-weight: 300;
            text-transform: uppercase;
            border-radius: 4px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* LEVEL GALLERY */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 30px;
            border-radius: 8px;
        }

        .level-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .level-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .level-btn.locked {
            opacity: 0.3;
            cursor: not-allowed;
            background: #000;
        }

        .level-btn .star-mark {
            font-size: 14px;
            color: #ffcc00;
            margin-top: 5px;
            display: none;
        }

        .level-btn.collected .star-mark {
            display: block;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        .hud-top {
            position: absolute;
            top: 20px;
            left: 30px;
            right: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        .hud-level-text {
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 2px;
            color: rgba(255, 255, 255, 0.8);
        }

        .hud-controls {
            display: flex;
            gap: 15px;
        }

        .icon-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 18px;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .star-status {
            color: #444;
            font-size: 24px;
            transition: color 0.5s;
        }

        .star-status.active {
            color: #ffcc00;
            text-shadow: 0 0 10px #ffcc00;
        }

        /* Transition */
        #transition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 100;
        }

        .debug {
            display: none;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <!-- UI LAYERS -->
        <div class="ui-layer">

            <!-- START SCREEN -->
            <div id="start-screen" class="screen active">
                <h1>Girl & Wind</h1>
                <button class="btn" id="btn-start">Start Game</button>
                <button class="btn" id="btn-levels">Levels</button>
            </div>

            <!-- LEVEL GALLERY -->
            <div id="level-gallery" class="screen">
                <h2>Select Level</h2>
                <div class="grid-container" id="level-grid">
                    <!-- Javascript will populate this -->
                </div>
                <button class="btn" id="btn-back-menu" style="margin-top: 30px;">Back</button>
            </div>

            <!-- HUD (In Game) -->
            <div id="hud">
                <div class="hud-top">
                    <div class="hud-level-text" id="hud-level-display">Level 1</div>
                    <div class="hud-controls">
                        <div class="icon-btn" id="hud-star">‚òÖ</div> <!-- Reactive star icon -->
                        <div class="icon-btn" id="btn-mute">üîä</div>
                        <div class="icon-btn" id="btn-reset">‚Üª</div>
                        <div class="icon-btn" id="btn-home">üè†</div>
                    </div>
                </div>
            </div>

            <!-- TRANSITION OVERLAY -->
            <div id="transition-overlay"></div>

        </div>

        <div class="controls" style="opacity: 0.5;">
            <div><strong>Controls</strong></div>
            <div>MOUSE - Move Wind Source</div>
            <div>HOLD W/A/S/D - Blow Wind</div>
            <div>R - Restart Level</div>
        </div>
    </div>

    <div class="debug" id="debugInfo"></div>

    <!-- External Data -->
    <script src="levels.js"></script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelIndicator = document.getElementById('levelIndicator');

        // Visual Style Constants
        const THEME = {
            bg: '#1a1b1e',
            grid: '#232428',
            wall: '#2a2b30',
            highlight: '#3a3b40',
            girl: '#ff6b9d',
            girlShadow: '#b03055',
            obstacle: '#333333',
            obstacleHighlight: '#444444',
            plank: '#cba', // Light minimalist wood/block
            plankShadow: '#876',
            wind: '#4ff',
            exit: '#44ffaa',
            gap: '#151619' // Slightly darker than BG
        };

        // Grid System
        const CELL_SIZE = 80;
        const GRID_W = 4;
        const GRID_H = 4;
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;

        // Calculate Grid Offset to center it
        const GRID_OFFSET_X = (GAME_WIDTH - (GRID_W * CELL_SIZE)) / 2;
        const GRID_OFFSET_Y = (GAME_HEIGHT - (GRID_H * CELL_SIZE)) / 2;

        // --- GLOBAL VISUALS ---
        let shakeIntensity = 0;
        let shakeX = 0;
        let shakeY = 0;
        let levelStartTime = 0;

        function addShake(amount) {
            shakeIntensity = Math.min(shakeIntensity + amount, 25);
        }

        // --- WIND FATIGUE ---
        let windFatigue = 0; // 0 = fresh, 100 = exhausted
        const FATIGUE_RATE = 35; // Per second of active use (increased from 15)
        const RECOVERY_RATE = 50; // Per second when idle (increased from 25)

        // Configuration
        const GIRL_SIZE = 40; // Smaller relative to cell (half size) for "small" feel
        const GIRL_SPEED = 150; // Adjusted for larger scale


        // Helper for rounded rectangles
        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            return ctx;
        }

        // Particle System
        class Particle {
            constructor(x, y, type = 'dust') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1.0;

                if (type === 'dust') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    this.decay = 0.005 + Math.random() * 0.01;
                    this.size = 1 + Math.random() * 2;
                    this.color = `rgba(255, 255, 255, ${0.05 + Math.random() * 0.1})`;
                } else if (type === 'wind') {
                    this.vx = 0;
                    this.vy = 0;
                    this.decay = 0.02 + Math.random() * 0.03;
                    this.size = 2 + Math.random() * 3;
                    this.color = '#4ff';
                }
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= this.decay;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;

                if (this.type === 'wind') {
                    ctx.fillStyle = THEME.wind;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            spawn(x, y, type, count = 1) {
                for (let i = 0; i < count; i++) {
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    this.particles.push(new Particle(x + offsetX, y + offsetY, type));
                }
            }

            update(dt) {
                // Update Audio
                audioSystem.updateWind(this.active, this.active ? 0.5 + Math.random() * 0.2 : 0);

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.update(dt);
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }

                // Always spawn background dust
                if (Math.random() < 0.2) {
                    this.spawn(
                        Math.random() * GAME_WIDTH,
                        Math.random() * GAME_HEIGHT,
                        'dust'
                    );
                }
            }

            draw(ctx) {
                for (let p of this.particles) {
                    p.draw(ctx);
                }
            }
        }

        const particles = new ParticleSystem();

        // ===============================
        // AUDIO SYSTEM (Procedural)
        // ===============================
        class AudioSystem {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.windNode = null;
                this.windFilter = null;
                this.windGain = null;
                this.isInit = false;
                this.windActive = false;
            }

            init() {
                if (this.isInit) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;

                this.ctx = new AudioContext();

                // Master Compressor to prevent clipping
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-10, this.ctx.currentTime);
                compressor.knee.setValueAtTime(40, this.ctx.currentTime);
                compressor.ratio.setValueAtTime(12, this.ctx.currentTime);
                compressor.attack.setValueAtTime(0, this.ctx.currentTime);
                compressor.release.setValueAtTime(0.25, this.ctx.currentTime);
                compressor.connect(this.ctx.destination);

                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5; // Overall volume
                this.masterGain.connect(compressor);

                this._initWind();
                this.isInit = true;

                // Resume if suspended (browser policy)
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            _initWind() {
                // White Noise Buffer
                const bufferSize = this.ctx.sampleRate * 2; // 2 seconds buffer
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                // Source (Looping)
                this.windNode = this.ctx.createBufferSource();
                this.windNode.buffer = buffer;
                this.windNode.loop = true;

                // Filter (Bandpass)
                this.windFilter = this.ctx.createBiquadFilter();
                this.windFilter.type = 'bandpass';
                this.windFilter.frequency.value = 800;
                this.windFilter.Q.value = 1;

                // Gain
                this.windGain = this.ctx.createGain();
                this.windGain.gain.value = 0;

                // Connect: Noise -> Filter -> Gain -> Master
                this.windNode.connect(this.windFilter);
                this.windFilter.connect(this.windGain);
                this.windGain.connect(this.masterGain);

                this.windNode.start();
            }

            // Update wind sound based on intensity (0.0 - 1.0)
            updateWind(active, intensity = 0.5) {
                if (!this.isInit) return;

                // Resume context if needed
                if (this.ctx.state === 'suspended') this.ctx.resume();

                const t = this.ctx.currentTime;
                // Gain Ramp
                // Gain Ramp
                if (active) {
                    // Boosted volume: 0.6 * intensity + 0.2 (was 0.3 + 0.1)
                    this.windGain.gain.target = 0.6 * intensity + 0.2;
                    this.windGain.gain.setTargetAtTime(0.6 * intensity + 0.2, t, 0.1);
                } else {
                    this.windGain.gain.setTargetAtTime(0, t, 0.2);
                }

                // Frequency & Q Sweep
                // Higher intensity = higher pitch + more resonance (howling)
                const targetFreq = 800 + intensity * 1200; // 800 -> 2000 Hz
                const targetQ = 1 + intensity * 8; // 1 -> 9

                this.windFilter.frequency.setTargetAtTime(targetFreq, t, 0.1);
                this.windFilter.Q.setTargetAtTime(targetQ, t, 0.1);
            }

            // Play one-shot tone (Sine)
            _playTone(freq, duration, type = 'sine', vol = 0.2) {
                if (!this.isInit) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(freq, t);

                gain.gain.setValueAtTime(vol, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + duration);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(t + duration);
                return { osc, gain }; // Return for modulation
            }

            // Girl Expressions
            playExpression(type) {
                if (!this.isInit) return;
                const t = this.ctx.currentTime;

                if (type === '!') {
                    // Surprise: Chirp up
                    const { osc } = this._playTone(800, 0.15, 'sine', 0.3);
                    osc.frequency.linearRampToValueAtTime(1200, t + 0.1);
                } else if (type === '?') {
                    // Confused: Slide down with vibrato
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.setValueAtTime(600, t);
                    osc.frequency.linearRampToValueAtTime(400, t + 0.3);

                    // Vibrato
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = 10; // 10Hz wobble
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = 20; // 20Hz depth
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    lfo.start();

                    gain.gain.setValueAtTime(0.2, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    osc.stop(t + 0.3);
                } else if (type === '‚ô•') {
                    // Love: Major 3rd chord
                    this._playTone(523.25, 0.6, 'sine', 0.2); // C5
                    this._playTone(659.25, 0.6, 'sine', 0.2); // E5
                }
            }

            // Physics / Environment
            playImpact() {
                if (!this.isInit) return;
                // Heavy thud
                const { osc } = this._playTone(100, 0.2, 'triangle', 0.3);
                // Pitch drop for weight
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.1);
            }

            playSwitch() {
                if (!this.isInit) return;
                const t = this.ctx.currentTime;
                // Bright glitch click
                const { osc } = this._playTone(600, 0.08, 'square', 0.15);
                osc.frequency.exponentialRampToValueAtTime(800, t + 0.05);
            }

            playButtonPress() {
                if (!this.isInit) return;
                const t = this.ctx.currentTime;
                // Mechanical press down sound
                this._playTone(180, 0.06, 'sine', 0.2);
                setTimeout(() => this._playTone(220, 0.04, 'sine', 0.15), 30);
            }

            playChime(pitch = 1.0) {
                if (!this.isInit) return;
                const t = this.ctx.currentTime;

                // Crystal chime - sine wave with harmonics
                const baseFreq = 800 * pitch;
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(baseFreq, t);

                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(baseFreq * 2, t); // Octave harmonic

                gain.gain.setValueAtTime(0.12, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);

                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(this.masterGain);

                osc1.start();
                osc2.start();
                osc1.stop(t + 0.8);
                osc2.stop(t + 0.8);
            }

            playWin() {
                if (!this.isInit) return;
                // Victory Fanfare: C Major Arpeggio
                this._playTone(523.25, 0.1, 'sine', 0.2); // C5
                setTimeout(() => this._playTone(659.25, 0.1, 'sine', 0.2), 100); // E5
                setTimeout(() => this._playTone(783.99, 0.1, 'sine', 0.2), 200); // G5
                setTimeout(() => this._playTone(1046.5, 0.4, 'sine', 0.25), 300); // C6
            }
        }

        const audioSystem = new AudioSystem();

        // ===============================
        // GRID-BASED BFS PATHFINDING
        // ===============================

        // Â∞ÜÂÉèÁ¥†ÂùêÊ†áËΩ¨Êç¢‰∏∫ÁΩëÊ†ºÂùêÊ†á
        function pixelToGrid(x, y) {
            const col = Math.floor((x - GRID_OFFSET_X) / CELL_SIZE);
            const row = Math.floor((y - GRID_OFFSET_Y) / CELL_SIZE);
            return {
                col: Math.max(0, Math.min(GRID_W - 1, col)),
                row: Math.max(0, Math.min(GRID_H - 1, row))
            };
        }

        // Â∞ÜÁΩëÊ†ºÂùêÊ†áËΩ¨Êç¢‰∏∫ÂÉèÁ¥†ÂùêÊ†áÔºàÊ†ºÂ≠ê‰∏≠ÂøÉÔºåË∞ÉÊï¥‰∏∫Â•≥Â≠©‰ΩçÁΩÆÔºâ
        function gridToPixel(col, row) {
            return {
                x: GRID_OFFSET_X + col * CELL_SIZE + (CELL_SIZE - GIRL_SIZE) / 2,
                y: GRID_OFFSET_Y + row * CELL_SIZE + (CELL_SIZE - GIRL_SIZE) / 2
            };
        }

        // Ê£ÄÊü•Êüê‰∏™Ê†ºÂ≠êÊòØÂê¶ÂèØÈÄöË°å
        function isGridCellWalkable(col, row, obstacles, blockages, gaps, hardBlocks, ignoreEntities = []) {
            if (col < 0 || col >= GRID_W || row < 0 || row >= GRID_H) return false;

            const cellX = GRID_OFFSET_X + col * CELL_SIZE;
            const cellY = GRID_OFFSET_Y + row * CELL_SIZE;

            // Ê£ÄÊü•ÈöúÁ¢çÁâ©
            for (let obs of obstacles) {
                if (ignoreEntities.includes(obs)) continue;
                if (cellX < obs.x + obs.width &&
                    cellX + CELL_SIZE > obs.x &&
                    cellY < obs.y + obs.height &&
                    cellY + CELL_SIZE > obs.y) {
                    return false;
                }
            }

            // Ê£ÄÊü• blockagesÔºàÂè™Êúâ blocked Áä∂ÊÄÅÊâçÈòªÊå°Ôºâ
            for (let b of blockages) {
                if (ignoreEntities.includes(b)) continue;
                if (b.blocked) {
                    if (cellX < b.x + b.width &&
                        cellX + CELL_SIZE > b.x &&
                        cellY < b.y + b.height &&
                        cellY + CELL_SIZE > b.y) {
                        return false;
                    }
                }
            }

            // Ê£ÄÊü• gapsÔºàÂè™ÊúâÊú™Â°´ÂÖÖÁöÑ gap ÊâçÈòªÊå°Ôºâ
            for (let g of gaps) {
                if (!g.isFilled) {
                    if (cellX < g.x + g.width &&
                        cellX + CELL_SIZE > g.x &&
                        cellY < g.y + g.height &&
                        cellY + CELL_SIZE > g.y) {
                        return false;
                    }
                }
            }

            // Ê£ÄÊü• hardBlocks (‰∏çÂèØÁ©øËøá)
            if (hardBlocks) {
                for (let hb of hardBlocks) {
                    if (ignoreEntities.includes(hb)) continue;
                    if (cellX < hb.x + hb.width &&
                        cellX + CELL_SIZE > hb.x &&
                        cellY < hb.y + hb.height &&
                        cellY + CELL_SIZE > hb.y) {
                        return false;
                    }
                }
            }

            return true;
        }

        // BFS ÊâæÊúÄÁü≠Ë∑ØÂæÑÔºåËøîÂõûÂÉèÁ¥†ÂùêÊ†áÊï∞ÁªÑÔºàwaypointsÔºâ
        // Â¶ÇÊûúÁªàÁÇπ‰∏çÂèØËææÔºåËøîÂõûÂà∞ÊúÄÊé•ËøëÁªàÁÇπÁöÑÂèØËææÊ†ºÂ≠êÁöÑË∑ØÂæÑ
        function findGridPath(startX, startY, endX, endY, obstacles, blockages, gaps, hardBlocks, ignoreEntities = []) {
            const start = pixelToGrid(startX, startY);
            const end = pixelToGrid(endX, endY);

            // Â¶ÇÊûúËµ∑ÁÇπÁªàÁÇπÁõ∏ÂêåÔºåÁõ¥Êé•ËøîÂõû
            if (start.col === end.col && start.row === end.row) {
                return [];
            }

            // Ëµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑË∑ùÁ¶ª
            const startDist = Math.abs(start.col - end.col) + Math.abs(start.row - end.row);

            // BFS ÈòüÂàó
            const queue = [{ col: start.col, row: start.row, path: [] }];
            const visited = new Set();
            visited.add(`${start.col},${start.row}`);

            // ËÆ∞ÂΩïÁúüÊ≠£ÊúùÁªàÁÇπÊñπÂêëÁöÑÊúÄËøú‰ΩçÁΩÆ
            let bestPath = [];
            let bestDist = startDist;

            // Âõõ‰∏™ÊñπÂêë
            const directions = [
                { dc: 0, dr: -1 }, { dc: 0, dr: 1 },
                { dc: -1, dr: 0 }, { dc: 1, dr: 0 }
            ];

            while (queue.length > 0) {
                const current = queue.shift();

                for (let dir of directions) {
                    const newCol = current.col + dir.dc;
                    const newRow = current.row + dir.dr;
                    const key = `${newCol},${newRow}`;

                    if (visited.has(key)) continue;
                    if (!isGridCellWalkable(newCol, newRow, obstacles, blockages, gaps, ignoreEntities)) continue;

                    visited.add(key);

                    const newPath = [...current.path, { col: newCol, row: newRow }];

                    // ÊâæÂà∞ÁªàÁÇπÔºÅ
                    if (newCol === end.col && newRow === end.row) {
                        return newPath.map(p => gridToPixel(p.col, p.row));
                    }

                    // Ê£ÄÊü•ÊòØÂê¶ÊØîÂΩìÂâçÊúÄ‰Ω≥‰ΩçÁΩÆÊõ¥Êé•ËøëÁªàÁÇπ
                    const dist = Math.abs(newCol - end.col) + Math.abs(newRow - end.row);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestPath = newPath;
                    }

                    queue.push({ col: newCol, row: newRow, path: newPath });
                }
            }

            // Ê≤°ÊâæÂà∞ÂÆåÊï¥Ë∑ØÂæÑÔºå‰ΩÜÂ¶ÇÊûúÊúâÊõ¥Êé•ËøëÁªàÁÇπÁöÑ‰ΩçÁΩÆÂ∞±ËøîÂõûÈÇ£‰∏™Ë∑ØÂæÑ
            if (bestPath.length > 0 && bestDist < startDist) {
                return bestPath.map(p => gridToPixel(p.col, p.row));
            }

            // Êó†Ê≥ïÊõ¥Êé•ËøëÁªàÁÇπ‰∫Ü
            return [];
        }

        // Girl with "Thomas Was Alone" Aesthetics
        class Girl {
            constructor(x, y, goalPos) {
                this.x = x;
                this.y = y;
                this.width = GIRL_SIZE;
                this.height = GIRL_SIZE;

                // Set explicitly from parsed goalPos
                if (goalPos) {
                    this.goalX = goalPos.x + (CELL_SIZE - GIRL_SIZE) / 2;
                    this.goalY = goalPos.y + (CELL_SIZE - GIRL_SIZE) / 2;
                } else {
                    this.goalX = GAME_WIDTH - 50;
                    this.goalY = GAME_HEIGHT / 2;
                }

                // Final Goal (The Exit) - Persistent
                this.finalGoalX = this.goalX;
                this.finalGoalY = this.goalY;

                // currentGoal is the IMMEDIATE waypoint we are walking towards
                this.currentGoalX = this.goalX;
                this.currentGoalY = this.goalY;

                // Waypoint Queue for L-Shaped movement
                this.pathQueue = [];

                this.state = 'WALKING';
                this.speed = GIRL_SPEED;
                this.color = '#ff6b9d';
                this.stateTimer = 0;

                this.stateTimer = 0;

                this.detourPath = null;
                this.hasDetoured = false;
                this.reachedWaypoint = false;
                this.stuckAtClosest = false; // Ê†áËÆ∞ÊòØÂê¶Â∑≤Âà∞ËææÊúÄËøë‰ΩçÁΩÆ

                // Animation
                this.bobOffset = 0;
                this.eyeOffset = { x: 0, y: 0 };
                this.blinkTimer = 0;
                this._expression = '';

                this.lastEnvVersion = 0;
            }

            get expression() { return this._expression; }
            set expression(val) {
                if (this._expression !== val) {
                    this._expression = val;
                    if (val === '!' || val === '?' || val === '‚ô•') {
                        audioSystem.playExpression(val);
                    }
                }
            }



            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                roundRect(ctx, this.x + 5, this.y + 5 + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Body
                ctx.fillStyle = THEME.girl;
                roundRect(ctx, this.x, this.y + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Inner Highlights (Bevel effect)
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(this.x, this.y + this.bobOffset, this.width, 4);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(this.x, this.y + this.height - 4 + this.bobOffset, this.width, 4);

                // Expressions (Eyes)
                ctx.fillStyle = '#fff';
                const eyeY = this.y + this.height / 3 + this.bobOffset;

                // Normal Eyes
                let leftEyeX = this.x + 10 + this.eyeOffset.x;
                let rightEyeX = this.x + this.width - 14 + this.eyeOffset.x;
                let eyeH = 8;

                if (this.blinkTimer > 0) {
                    eyeH = 2; // Blinking
                }

                // Draw Eyes
                if (this.state !== 'REACHED_GOAL') {
                    ctx.fillRect(leftEyeX, eyeY, 4, eyeH);
                    ctx.fillRect(rightEyeX, eyeY, 4, eyeH);
                } else {
                    // Happy eyes ^ ^
                    ctx.beginPath();
                    ctx.moveTo(leftEyeX - 2, eyeY + 4);
                    ctx.lineTo(leftEyeX + 2, eyeY);
                    ctx.lineTo(leftEyeX + 6, eyeY + 4);

                    ctx.moveTo(rightEyeX - 2, eyeY + 4);
                    ctx.lineTo(rightEyeX + 2, eyeY);
                    ctx.lineTo(rightEyeX + 6, eyeY + 4);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Status Indicator (Bubble)
                if (this.expression) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.expression, this.x + this.width / 2, this.y - 12 + this.bobOffset);
                }
            }

            update(dt, obstacles, blockages, gaps, switches, collectibles, hardBlocks, girlButtons) {
                // Update animation state
                // ‰∏çÊôÉÂä®ÔºåËµ∞Áõ¥Á∫ø
                // this.bobOffset = Math.sin(Date.now() / 150) * 2;
                if (Math.random() < 0.01) this.blinkTimer = 10;
                if (this.blinkTimer > 0) this.blinkTimer--;

                // Logic State Machine
                switch (this.state) {
                    case 'WALKING':
                        // Check collision with Blockages specifically to trigger "BLOCKED" state
                        // Note: updateWalking handles physics stop.
                        // If updateWalking returns true, it means we hit something.
                        if (this.updateWalking(dt, obstacles, blockages, gaps, switches, collectibles, hardBlocks, girlButtons)) {
                            this.state = 'BLOCKED';
                            this.stateTimer = 0;
                            this.expression = '!';
                        }
                        break;

                    case 'BLOCKED':
                        // 1. Bounce -> Stop
                        // 2. Expression '?'
                        this.stateTimer += dt;
                        this.expression = '?';
                        if (this.stateTimer > 0.5) {
                            this.state = 'TRY_PUSH';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'STOPPED':
                        // If stopped for too long, maybe we should think?
                        this.stateTimer += dt;
                        this.expression = '?';
                        if (this.stateTimer > 1.0) {
                            // Only switch to thinking if we have somewhere else to go or stuck
                            // Actually, if we are just stopped by a wall but checkEnvironment says we can reach goal (false positive?), we must retry?
                            // Let's just go to Thinking
                            this.state = 'THINKING';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'TRY_PUSH':
                        // 3. Expression '>' (Trying to move forward)
                        this.expression = '>';
                        this.stateTimer += dt;

                        // ‰∏çÁßªÂä®‰ΩçÁΩÆÔºåÂè™ÂÅöËßÜËßâÊïàÊûúÔºàbobOffset Â∑≤Á¶ÅÁî®Ôºâ
                        // ÈÅøÂÖçÊääËá™Â∑±Êé®ËøõÈöúÁ¢çÁâ©Èáå

                        if (this.stateTimer > 0.8) {
                            this.state = 'THINKING';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'THINKING':
                        this.stateTimer += dt;
                        this.expression = '...';

                        // Check Environment to see if we have a plan
                        const foundPlan = this.checkEnvironment(obstacles, blockages, gaps, switches, collectibles, hardBlocks, girlButtons);

                        if (foundPlan) {
                            // Check if environment actually changed to warrant an exclamation
                            let envChanged = false;
                            if (window.gameManager && window.gameManager.envVersion > this.lastEnvVersion) {
                                envChanged = true;
                                this.lastEnvVersion = window.gameManager.envVersion;
                            }

                            if (envChanged) {
                                // We found a plan AND the environment changed (player did something)
                                // Show '!' and act
                                this.state = 'HESITATE';
                                this.stateTimer = 0;
                                this.expression = '!';
                            } else {
                                // Plan found, but environment is same. Just go do it without fanfare.
                                // Or if we were STOPPED, maybe we should just go?
                                // If we transition directly to WALKING, we skip HESITATE ('!')
                                this.state = 'WALKING';
                                this.pathQueue = [];
                                // Keep expression as '...' or clear it?
                                this.expression = '';
                            }
                        } else {
                            // No new plan, just stuck or waiting
                            // Don't show '!', go back to STOPPED or stay THINKING for a bit
                            // If we just transition to STOPPED, we will show '?'
                            this.state = 'STOPPED';
                            this.stateTimer = 0;
                            // Keep expression as '...' or let STOPPED set it to '?'
                            this.expression = '...';
                        }
                        break;

                    case 'HESITATE':
                        this.stateTimer += dt;
                        this.expression = '!';
                        if (this.stateTimer > 0.5) {
                            this.state = 'ASSESS'; // Quickly assess
                            this.stateTimer = 0;
                        }
                        break;

                    case 'ASSESS':
                        this.stateTimer += dt;
                        this.expression = '...';
                        if (this.stateTimer > 0.5) {
                            this.state = 'WALKING';
                            // Ensure path is planned
                            this.pathQueue = [];
                        }
                        break;

                    case 'REACHED_GOAL':
                        this.expression = '‚ô•';
                        break;
                }

                // Always try to plan path if walking
                if (this.state === 'WALKING') {
                    this.planPath(obstacles, blockages, gaps, hardBlocks);
                }
            }

            checkEnvironment(obstacles, blockages, gaps, switches, collectibles, hardBlocks) {
                // ÁÆÄÂåñÁâàÔºöÁõ¥Êé•Ê£ÄÊü•ÊòØÂê¶ËÉΩÂà∞ËææÁªàÁÇπÔºåBFS ‰ºöËá™Âä®ÊâæË∑Ø

                // PRIORITY 0: COLLECTIBLES
                if (collectibles && collectibles.length > 0) {
                    // Find closest uncollected and reachable
                    let bestTarget = null;
                    let minDist = Infinity;

                    for (let col of collectibles) {
                        if (!col.collected) {
                            if (this.canReachGoal(col.x, col.y, obstacles, blockages, gaps, hardBlocks)) {
                                const dx = col.x - this.x;
                                const dy = col.y - this.y;
                                const d = dx * dx + dy * dy;
                                if (d < minDist) {
                                    minDist = d;
                                    bestTarget = col;
                                }
                            }
                        }
                    }

                    if (bestTarget) {
                        this.stuckAtClosest = false;
                        if (this.currentGoalX !== bestTarget.x || this.currentGoalY !== bestTarget.y) {
                            this.currentGoalX = bestTarget.x;
                            this.currentGoalY = bestTarget.y;
                            this.goalX = bestTarget.x;
                            this.goalY = bestTarget.y;
                            this.pathQueue = [];
                            return true;
                        }
                        return true; // Keep going to collectible
                    }
                }

                // If no collectibles or unreachable, check if we can reach Final Goal (Exit)
                if (this.canReachGoal(this.finalGoalX, this.finalGoalY, obstacles, blockages, gaps, hardBlocks)) {
                    // Reset to exit
                    this.goalX = this.finalGoalX;
                    this.goalY = this.finalGoalY;
                    this.stuckAtClosest = false;
                    return true;
                }

                // PRIORITY 2: SWITCHES (Unlock Blockages)
                if (switches && switches.length > 0) {
                    const keySwitch = switches.find(s => !s.active);
                    if (keySwitch && this.canReachGoal(keySwitch.x, keySwitch.y, obstacles, blockages, gaps, hardBlocks)) {
                        this.stuckAtClosest = false; // ÈáçÁΩÆÊ†áËÆ∞
                        if (this.currentGoalX !== keySwitch.x || this.currentGoalY !== keySwitch.y) {
                            this.currentGoalX = keySwitch.x;
                            this.currentGoalY = keySwitch.y;
                            this.goalX = this.currentGoalX;
                            this.goalY = this.currentGoalY;
                            this.pathQueue = [];
                            return true;
                        }
                        return true;
                    }
                }

                // PRIORITY 2.5: GIRL BUTTONS (Unlock HardBlocks)
                if (girlButtons && girlButtons.length > 0) {
                    for (let gb of girlButtons) {
                        if (!gb.pressed && this.canReachGoal(gb.x, gb.y, obstacles, blockages, gaps, hardBlocks)) {
                            this.stuckAtClosest = false;
                            if (this.currentGoalX !== gb.x || this.currentGoalY !== gb.y) {
                                this.currentGoalX = gb.x;
                                this.currentGoalY = gb.y;
                                this.goalX = gb.x;
                                this.goalY = gb.y;
                                this.pathQueue = [];
                                return true;
                            }
                            return true;
                        }
                    }
                }

                // ÊØèÊ¨°ÊÄùËÄÉÂêéÈÉΩÈáçÁΩÆÂç°‰ΩèÊ†áËÆ∞ÔºåËøôÊ†∑Â•≥Â≠©ÂèØ‰ª•ÈáçÊñ∞Â∞ùËØïËµ∞
                // Â¶ÇÊûúËøòÊòØË¢´Âç°‰ΩèÔºåplanPath ‰ºöÈáçÊñ∞ËÆæÁΩÆËøô‰∏™Ê†áËÆ∞
                this.stuckAtClosest = false;

                // Âç≥‰ΩøÁªàÁÇπ‰∏çÂèØËææÔºå‰πüËÆ©Â•≥Â≠©ÁªßÁª≠ÂæÄÁªàÁÇπÊñπÂêëËµ∞
                this.currentGoalX = this.finalGoalX;
                this.currentGoalY = this.finalGoalY;
                this.goalX = this.finalGoalX;
                this.goalY = this.finalGoalY;
                return true;
            }

            // ‰ΩøÁî® BFS Ê£ÄÊü•ÊòØÂê¶ÂèØËææ
            canReachGoal(targetX, targetY, obstacles, blockages, gaps, ignoreEntities = []) {
                const start = pixelToGrid(this.x, this.y);
                const end = pixelToGrid(targetX, targetY);

                // Â¶ÇÊûúËµ∑ÁÇπÁªàÁÇπÁõ∏ÂêåÔºåÂèØËææ
                if (start.col === end.col && start.row === end.row) return true;

                // ‰ΩøÁî® BFS Ê£ÄÊü•ÊòØÂê¶ÊúâË∑ØÂæÑ
                const queue = [{ col: start.col, row: start.row }];
                const visited = new Set();
                visited.add(`${start.col},${start.row}`);

                const directions = [
                    { dc: 0, dr: -1 }, { dc: 0, dr: 1 },
                    { dc: -1, dr: 0 }, { dc: 1, dr: 0 }
                ];

                while (queue.length > 0) {
                    const current = queue.shift();

                    for (let dir of directions) {
                        const newCol = current.col + dir.dc;
                        const newRow = current.row + dir.dr;
                        const key = `${newCol},${newRow}`;

                        if (visited.has(key)) continue;
                        if (!isGridCellWalkable(newCol, newRow, obstacles, blockages, gaps, hardBlocks, ignoreEntities)) continue;

                        if (newCol === end.col && newRow === end.row) return true;

                        visited.add(key);
                        queue.push({ col: newCol, row: newRow });
                    }
                }
                return false;
            }

            planPath(obstacles, blockages, gaps, hardBlocks) {
                // If queue has items, continue consuming
                if (this.pathQueue.length > 0) return;

                // If close to goal, done
                if (Math.abs(this.x - this.goalX) < 5 && Math.abs(this.y - this.goalY) < 5) {
                    this.state = 'REACHED_GOAL';
                    return;
                }

                // Â∞ùËØïÁîüÊàêÂÆåÊï¥Ë∑ØÂæÑ
                const path = findGridPath(this.x, this.y, this.goalX, this.goalY, obstacles, blockages, gaps, hardBlocks);

                if (path.length > 0) {
                    this.pathQueue = path;
                } else {
                    // Ê≤°ÊúâÂÆåÊï¥Ë∑ØÂæÑÔºåËß¶Âèë BLOCKED
                    if (this.state === 'WALKING') {
                        this.state = 'BLOCKED';
                        this.stateTimer = 0;
                        this.expression = '!';
                    }
                }
            }

            generatePath(tx, ty, obstacles, blockages, gaps, hardBlocks) {
                // ‰ΩøÁî® BFS Ëá™Âä®ÊâæÊúÄÁü≠Ë∑ØÂæÑ
                this.pathQueue = findGridPath(this.x, this.y, tx, ty, obstacles, blockages, gaps, hardBlocks);
            }

            checkCollisionLine(x1, y1, x2, y2, obstacles, blockages, gaps, ignoreEntities = []) {
                // Check if any point along line collides?
                let minX = Math.min(x1, x2);
                let maxX = Math.max(x1, x2) + this.width;
                let minY = Math.min(y1, y2);
                let maxY = Math.max(y1, y2) + this.height;

                for (let o of obstacles) {
                    if (ignoreEntities.includes(o)) continue;
                    if (maxX > o.x && minX < o.x + o.width && maxY > o.y && minY < o.y + o.height) return true;
                }
                for (let b of blockages) {
                    if (ignoreEntities.includes(b)) continue;
                    if (b.blocked) {
                        if (maxX > b.x && minX < b.x + b.width && maxY > b.y && minY < b.y + b.height) return true;
                    }
                }
                // Check Gaps (must be filled)
                for (let g of gaps) {
                    if (!g.isFilled) {
                        if (maxX > g.x && minX < g.x + g.width && maxY > g.y && minY < g.y + g.height) return true;
                    }
                }
                return false;
            }

            updateWalking(dt, obstacles, blockages, gaps, switches, collectibles, hardBlocks, girlButtons) {
                if (this.pathQueue.length === 0) return;

                const target = this.pathQueue[0];
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 5) {
                    // Reached waypoint - Á≤æÁ°ÆÂØπÈΩêÂà∞Ê†ºÂ≠ê‰∏≠ÂøÉ
                    this.pathQueue.shift();
                    this.x = target.x;
                    this.y = target.y;

                    // Ë∑ØÂæÑËµ∞ÂÆå‰∫ÜÔºåËÆ©Áä∂ÊÄÅÊú∫Âú®‰∏ã‰∏ÄÂ∏ßÂ§ÑÁêÜ
                    // ‰∏çË¶ÅÂú®ËøôÈáåÁõ¥Êé•ÁîüÊàêÊñ∞Ë∑ØÂæÑÔºåÈÅøÂÖçÊù•ÂõûÊôÉ
                    if (this.pathQueue.length === 0) {
                        if (this.checkEnvironment(obstacles, blockages, gaps, switches, collectibles, hardBlocks, girlButtons)) {
                            this.state = 'THINKING'; // Found path or switch
                        } else {
                            this.state = 'THINKING'; // No obvious path, just think
                        }
                    }
                    return;
                }

                // ÁßªÂä® - ÊØèÊ¨°Âè™Ëµ∞‰∏Ä‰∏™ÊñπÂêëÔºåÁ°Æ‰øùËµ∞Áõ¥Á∫ø
                let moveX = 0, moveY = 0;
                if (Math.abs(dx) > 2) {
                    moveX = Math.sign(dx) * this.speed * dt;
                } else if (Math.abs(dy) > 2) {
                    moveY = Math.sign(dy) * this.speed * dt;
                }

                const newX = this.x + moveX;
                const newY = this.y + moveY;

                // Collision Check
                if (this.checkCollision(newX, newY, obstacles, gaps, blockages)) {
                    // Á¢∞Êíû‰∫ÜÔºåÂÅúÊ≠¢Âπ∂Ëß¶ÂèëÁä∂ÊÄÅÊú∫
                    this.state = 'STOPPED';
                    return true;
                }

                this.x = newX;
                this.y = newY;
                return false;
            }

            checkCollision(x, y, obstacles, gaps, blockages) {
                // Obstacles
                for (let obs of obstacles) {
                    if (x < obs.x + obs.width &&
                        x + this.width > obs.x &&
                        y < obs.y + obs.height &&
                        y + this.height > obs.y) {
                        return true;
                    }
                }

                // Blockages (if blocked) - Added this!
                if (blockages) {
                    for (let b of blockages) {
                        if (b.blocked) {
                            if (x < b.x + b.width &&
                                x + this.width > b.x &&
                                y < b.y + b.height &&
                                y + this.height > b.y) {
                                return true;
                            }
                        }
                    }
                }

                // Gaps logic (only if not filled)
                for (let gap of gaps) {
                    if (!gap.isFilled &&
                        x < gap.x + gap.width &&
                        x + this.width > gap.x &&
                        y < gap.y + gap.height &&
                        y + this.height > gap.y) {

                        // Check strict overlap (center point?)
                        // If center of girl is inside gap
                        const cx = x + this.width / 2;
                        const cy = y + this.height / 2;
                        if (cx > gap.x && cx < gap.x + gap.width &&
                            cy > gap.y && cy < gap.y + gap.height) {
                            return true; // Fall in gap
                        }
                    }
                }
                return false;
            }



        }

        // Obstacle (Wall/Block)
        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.x + 4, this.y + 4, this.width, this.height);

                // Body
                ctx.fillStyle = THEME.obstacle;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Top Highlight
                ctx.fillStyle = THEME.obstacleHighlight;
                ctx.fillRect(this.x, this.y, this.width, 4);
            }
        }

        // Collectible - Optional item to collect (star/gem)
        class Collectible {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.collected = false;
                this.spin = 0;
                this.bobOffset = 0;
            }

            update(dt, girl) {
                if (this.collected) return;

                this.spin += dt * 3;
                this.bobOffset = Math.sin(Date.now() / 200) * 3;

                // Check if girl touches it
                if (girl) {
                    const girlCenterX = girl.x + girl.width / 2;
                    const girlCenterY = girl.y + girl.height / 2;
                    const myCenterX = this.x + this.width / 2;
                    const myCenterY = this.y + this.height / 2;

                    const dist = Math.sqrt(
                        Math.pow(girlCenterX - myCenterX, 2) +
                        Math.pow(girlCenterY - myCenterY, 2)
                    );

                    if (dist < 35) {
                        this.collected = true;
                        // Count how many already collected for pitch climbing
                        const count = collectibles ? collectibles.filter(c => c.collected).length : 0;
                        audioSystem.playCollect(count);
                    }
                }
            }

            draw(ctx) {
                if (this.collected) return;

                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2 + this.bobOffset;

                // Glow effect
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffcc00';

                // Star shape
                ctx.fillStyle = '#ffcc00';
                ctx.translate(centerX, centerY);
                ctx.rotate(this.spin);

                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                    const r = i === 0 ? 12 : 12;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();

                // Inner highlight
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Gap (Hole)
        class Gap {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isFilled = false;
            }

            checkFilled(movables) {
                for (let obj of movables) {
                    if (obj.x < this.x + this.width &&
                        obj.x + obj.width > this.x &&
                        obj.y < this.y + this.height &&
                        obj.y + obj.height > this.y) {

                        const overlapWidth = Math.min(obj.x + obj.width, this.x + this.width) - Math.max(obj.x, this.x);
                        const overlapHeight = Math.min(obj.y + obj.height, this.y + this.height) - Math.max(obj.y, this.y);
                        const overlapArea = overlapWidth * overlapHeight;
                        const gapArea = this.width * this.height;
                        const coverageRatio = overlapArea / gapArea;

                        this.coverageRatio = coverageRatio;

                        if (coverageRatio > 0.5) {
                            this.isFilled = true;
                            // ÈîÅÂÆöÊú®ÊùøÂú® Gap ‰ΩçÁΩÆÔºåÂèòÊàêÊ°•
                            if (!obj.isLocked) {
                                obj.isLocked = true;
                                obj.x = this.x;
                                obj.y = this.y;
                                obj.vx = 0;
                                obj.vy = 0;

                                // Only trigger effects on first lock
                                audioSystem.playImpact('heavy');
                                addShake(15);
                                if (window.gameManager) window.gameManager.envVersion++;
                            }
                            this.filledBy = obj; // ËÆ∞ÂΩïÊòØÂì™‰∏™Êú®ÊùøÂ°´ÁöÑ
                            return;
                        }
                    }
                }
                this.isFilled = false;
                this.coverageRatio = 0;
                this.filledBy = null;
            }

            draw(ctx) {
                if (!this.isFilled) {
                    // Inner shadow effect
                    ctx.fillStyle = THEME.gap;
                    ctx.fillRect(this.x, this.y, this.width, this.height);

                    // Inner borders to give depth
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(this.x, this.y, this.width, 10); // Top inner shadow
                    ctx.fillRect(this.x, this.y, 10, this.height); // Left inner shadow
                }
            }
        }

        // Movable Object (Plank/Block) - Redesign: Sleek Slider
        class Movable {
            constructor(x, y, width, height, type = 'plank') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.90;
                this.mass = 2;
            }

            applyForce(fx, fy) {
                this.vx += fx / this.mass;
                this.vy += fy / this.mass;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vx *= this.friction;
                this.vy *= this.friction;

                if (Math.abs(this.vx) < 1) this.vx = 0;
                if (Math.abs(this.vy) < 1) this.vy = 0;

                // Limits
                // Limits (Grid Boundaries)
                const minX = GRID_OFFSET_X;
                const maxX = GRID_OFFSET_X + GRID_W * CELL_SIZE - this.width;
                const minY = GRID_OFFSET_Y;
                const maxY = GRID_OFFSET_Y + GRID_H * CELL_SIZE - this.height;

                if (this.x < minX) { this.x = minX; this.vx = 0; }
                if (this.x > maxX) { this.x = maxX; this.vx = 0; }
                if (this.y < minY) { this.y = minY; this.vy = 0; }
                if (this.y > maxY) { this.y = maxY; this.vy = 0; }
            }

            draw(ctx) {
                if (this.type === 'plank') {
                    // Sleek Industrial Design

                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    roundRect(ctx, this.x + 4, this.y + 4, this.width, this.height, 4);
                    ctx.fill();

                    // Main Body: Dark Grey
                    ctx.fillStyle = '#333';
                    roundRect(ctx, this.x, this.y, this.width, this.height, 4);
                    ctx.fill();

                    // Accent: Neon Cyan Edge
                    const lineWidth = 4;
                    ctx.fillStyle = '#0ff'; // Neon

                    // Draw accent strip on left
                    ctx.fillRect(this.x + 10, this.y + 10, 5, this.height - 20);

                    // Draw accent strip on right
                    ctx.fillRect(this.x + this.width - 15, this.y + 10, 5, this.height - 20);

                    // Center detail (Grip lines)
                    ctx.fillStyle = '#444';
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 20, 30, 4);
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 30, 30, 4);
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 40, 30, 4);
                }
            }
        }

        // Blockage - Redesign: Geometric Cluster (Shatter Effect)
        class Blockage {
            constructor(x, y, width, height, revealsPath = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.blocked = true;
                this.revealsPath = revealsPath;
                this.opacity = 1.0;

                // Parts for shattered visual
                this.parts = [];
                const cols = 3;
                const rows = 3;
                const partW = width / cols;
                const partH = height / rows;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        this.parts.push({
                            ox: c * partW, // Offset X
                            oy: r * partH, // Offset Y
                            w: partW - 2,  // Gap
                            h: partH - 2,
                            vx: 0,
                            vy: 0,
                            active: true
                        });
                    }
                }
            }

            update(dt) {
                // Base class does nothing, RegeneratingBlockage overrides this
            }

            open() {
                if (this.blocked) {
                    this.opening = true; // Start animation
                    this.blocked = false; // Logically open immediately? Or wait? 
                    // Let's say logically open so pathfinding sees it, but visual lags
                    audioSystem.playSwitch(); // Mechanical sound
                }
            }

            draw(ctx) {
                if (this.blocked) {
                    // Draw clustered parts
                    ctx.fillStyle = '#C2B280'; // Sand/Stone color
                    // Or maybe a bit more geometric "glitch" color
                    ctx.fillStyle = '#aaa';

                    for (let p of this.parts) {
                        ctx.fillStyle = '#555';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);

                        // Highlight
                        ctx.fillStyle = '#777';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, 4);
                    }

                } else {
                    // Shatter animation
                    if (this.opacity > 0) {
                        this.opacity -= 0.02;

                        for (let p of this.parts) {
                            if (!p.vx) {
                                // Explode outwards
                                p.vx = (Math.random() - 0.5) * 10;
                                p.vy = (Math.random() - 0.5) * 10;
                            }
                            p.ox += p.vx;
                            p.oy += p.vy;

                            ctx.fillStyle = `rgba(150, 150, 150, ${this.opacity})`;
                            ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);
                        }
                    }

                    // Reveal path visual
                    if (this.revealsPath) {
                        const wp = this.revealsPath.waypoint;
                        // Draw Waypoint marker
                        ctx.fillStyle = THEME.exit;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(wp.x, wp.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }

        // Wind System
        class Wind {
            constructor() {
                this.x = GAME_WIDTH / 2;
                this.y = 50;
                this.active = false;
                this.direction = { x: 0, y: 1 };
                this.strength = 150; // Reduced from 300 to 150
                this.size = 30;
                this.timer = 0;
                this.streams = []; // For visual effect
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
            }

            setDirection(key) {
                switch (key) {
                    case 'w': case 'W': this.direction = { x: 0, y: -1 }; break;
                    case 's': case 'S': this.direction = { x: 0, y: 1 }; break;
                    case 'a': case 'A': this.direction = { x: -1, y: 0 }; break;
                    case 'd': case 'D': this.direction = { x: 1, y: 0 }; break;
                }
            }

            activate() {
                this.active = true;
            }

            stop() {
                this.active = false;
            }

            checkBlockages(blockages) {
                if (!this.active) return false;
                const windReach = 200;

                for (let blockage of blockages) {
                    if (!blockage.blocked) continue;

                    const toBlockageX = blockage.x + blockage.width / 2 - this.x;
                    const toBlockageY = blockage.y + blockage.height / 2 - this.y;
                    const distance = Math.sqrt(toBlockageX * toBlockageX + toBlockageY * toBlockageY);

                    if (distance < windReach) {
                        const dot = (toBlockageX * this.direction.x + toBlockageY * this.direction.y) / distance;
                        if (dot > 0.6) {
                            blockage.blocked = false;

                            // Explosion effect
                            particles.spawn(blockage.x + blockage.width / 2, blockage.y + blockage.height / 2, 'dust', 10);

                            if (window.gameManager) window.gameManager.envVersion++;

                            return true;
                        }
                    }
                }
                return false;
            }

            pushMovables(movables) {
                if (!this.active) return;
                const windReach = 250;

                // Calculate fatigue multiplier (max 70% reduction)
                const fatigueMultiplier = 1 - (windFatigue / 100) * 0.7;

                for (let obj of movables) {
                    const toObjX = obj.x + obj.width / 2 - this.x;
                    const toObjY = obj.y + obj.height / 2 - this.y;
                    const distance = Math.sqrt(toObjX * toObjX + toObjY * toObjY);

                    if (distance < windReach) {
                        const dot = (toObjX * this.direction.x + toObjY * this.direction.y) / distance;
                        if (dot > 0.5) {
                            const baseForceMagnitude = this.strength * (1 - distance / windReach);
                            const forceMagnitude = baseForceMagnitude * fatigueMultiplier;
                            const fx = this.direction.x * forceMagnitude;
                            const fy = this.direction.y * forceMagnitude;
                            obj.applyForce(fx, fy);

                            // Interaction particles
                            if (Math.random() < 0.1) {
                                particles.spawn(obj.x + Math.random() * obj.width, obj.y + Math.random() * obj.height, 'dust', 1);
                            }

                            // Notify AI (Throttle to avoid spamming version)
                            if (window.gameManager && Math.random() < 0.1) {
                                window.gameManager.envVersion++;
                            }
                        }
                    }
                }
            }

            checkSwitches(switches) {
                if (!this.active) return;
                for (let s of switches) {
                    const dx = this.x - (s.x + s.width / 2);
                    const dy = this.y - (s.y + s.height / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.size + s.width / 2) {
                        if (!s.active) {
                            s.active = true;
                            audioSystem.playSwitch();
                            // Trigger logic handled in game loop or switch update
                        }
                    }
                }
            }

            draw(ctx) {
                this.timer += 0.1;

                if (this.active) {
                    // Update streams
                    if (Math.random() < 0.3) {
                        this.streams.push({
                            x: this.x + (Math.random() - 0.5) * 40,
                            y: this.y + (Math.random() - 0.5) * 40,
                            len: 0,
                            maxLen: 50 + Math.random() * 100,
                            alpha: 1.0,
                            width: 2 + Math.random() * 3
                        });
                    }
                }

                // Calculate visual fatigue factor
                const fatigueVisual = windFatigue / 100;

                // Draw streams
                for (let i = this.streams.length - 1; i >= 0; i--) {
                    let s = this.streams[i];
                    s.len += 10;
                    s.alpha -= 0.05;
                    s.x += this.direction.x * 5;
                    s.y += this.direction.y * 5;

                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x + this.direction.x * s.len, s.y + this.direction.y * s.len);

                    // Fade to gray when fatigued
                    const freshness = 1 - fatigueVisual;
                    const r = 100 + (155 - 100) * fatigueVisual; // 100 -> 155 (gray)
                    const g = 255;
                    const b = 255 - (55 * fatigueVisual); // 255 -> 200
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${s.alpha * 0.5 * freshness})`;
                    ctx.lineWidth = s.width;
                    ctx.stroke();

                    if (s.alpha <= 0) this.streams.splice(i, 1);
                }

                // Cursor visual
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.stroke();

                if (this.active) {
                    // Wind gusts visual (lines)
                    const endX = this.x + this.direction.x * 150;
                    const endY = this.y + this.direction.y * 150;

                    const freshness = 1 - fatigueVisual;
                    const grad = ctx.createLinearGradient(this.x, this.y, endX, endY);
                    grad.addColorStop(0, 'rgba(100, 255, 255, 0.0)');
                    grad.addColorStop(0.2, `rgba(100, 255, 255, ${0.3 * freshness})`);
                    grad.addColorStop(1, 'rgba(100, 255, 255, 0.0)');

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 40;
                    ctx.lineCap = 'round';
                    // Using a blurred line for "air" feel?
                    // Canvas doesn't support easy blur on stroke without filter
                    // Just accept the gradient for now as a "beam"
                    ctx.stroke();
                }
            }
        }

        // Regenerating Blockage (Grows back)
        class RegeneratingBlockage extends Blockage {
            constructor(x, y, width, height, revealsPath = null) {
                super(x, y, width, height, revealsPath);
                this.regenTime = 3.0; // Seconds to regenerate
                this.regenTimer = 0;
                this.isRegenerating = false;
            }

            update(dt) {
                super.update(dt);
                if (!this.blocked) {
                    this.regenTimer += dt;
                    if (this.regenTimer > this.regenTime) {
                        // Regenerate!
                        this.blocked = true;
                        this.health = 100;
                        this.regenTimer = 0;

                        // ÈáçÁΩÆËßÜËßâÁä∂ÊÄÅ
                        this.opacity = 1.0;
                        // ÈáçÁΩÆ parts ‰ΩçÁΩÆ
                        const cols = 3;
                        const rows = 3;
                        const partW = this.width / cols;
                        const partH = this.height / rows;
                        this.parts = [];
                        for (let r = 0; r < rows; r++) {
                            for (let c = 0; c < cols; c++) {
                                this.parts.push({
                                    ox: c * partW,
                                    oy: r * partH,
                                    w: partW - 2,
                                    h: partH - 2,
                                    vx: 0,
                                    vy: 0,
                                    active: true
                                });
                            }
                        }
                    }
                }
            }

            draw(ctx) {
                super.draw(ctx);

                // Draw regeneration indicator (if clearing)
                if (!this.blocked) {
                    const progress = this.regenTimer / this.regenTime;
                    ctx.save();
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.2;
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(this.x + 10, this.y + 10, this.width - 20, this.height - 20);

                    // Progress bar or growing ghost
                    ctx.fillStyle = 'rgba(255, 68, 68, 0.1)';
                    ctx.fillRect(this.x, this.y + this.height * (1 - progress), this.width, this.height * progress);
                    ctx.restore();
                }
            }
        }

        class IronRegenBlock extends RegeneratingBlockage {
            constructor(x, y, width, height, revealsPath = null) {
                super(x, y, width, height, revealsPath);
                this.isIron = false;
            }

            update(dt) {
                const wasBlocked = this.blocked;
                super.update(dt);

                // If we just regenerated (transitioned from open to blocked)
                // Lock into Iron state
                if (!wasBlocked && this.blocked) {
                    this.isIron = true;
                    // Visual effect for hardening?
                    particles.spawn(this.x + this.width / 2, this.y + this.height / 2, '#555', 10);
                }
            }

            checkWind(wind) {
                if (this.isIron) return false;
                return super.checkWind(wind);
            }

            draw(ctx) {
                if (this.blocked && this.isIron) {
                    // Iron State Display
                    ctx.fillStyle = '#2d3748'; // Dark Iron
                    // Draw geometric parts but dark and solid looking
                    for (let p of this.parts) {
                        ctx.fillStyle = '#1a202c';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);

                        // Metallic sheen
                        ctx.fillStyle = '#4a5568';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, 2);

                        // Red Locked Indicator
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(this.x + p.ox + p.w / 2 - 2, this.y + p.oy + p.h / 2 - 2, 4, 4);
                    }

                    // Main border
                    ctx.strokeStyle = '#e53e3e'; // Red lock border
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x + 1, this.y + 1, this.width - 2, this.height - 2);

                } else {
                    // Normal behavior (Regenerating or Open)
                    super.draw(ctx);

                    // Add a hint that this IS an Iron block (before regular regen)
                    // Maybe a small grey icon or tint?
                    if (this.blocked && !this.isIron) {
                        ctx.save();
                        ctx.fillStyle = '#aaa';
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }
        }

        // Door - Controlled by WindSwitch, slides open instead of shattering
        class Door {
            constructor(x, y, width, height, id = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.id = id;
                this.blocked = true;
                this.openProgress = 0; // 0 = closed, 1 = fully open
                this.opening = false;
            }

            update(dt) {
                if (this.opening && this.openProgress < 1) {
                    this.openProgress += dt * 2; // Open over 0.5 seconds
                    if (this.openProgress >= 1) {
                        this.openProgress = 1;
                        this.blocked = false;
                    }
                }
            }

            open() {
                this.opening = true;
            }

            draw(ctx) {
                // Door frame (always visible)
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.x + 2, this.y + 2, this.width - 4, this.height - 4);

                const openOffset = this.openProgress * this.height * 0.9;

                // Door panels (slide up when opening)
                ctx.fillStyle = '#7b5544'; // Wood color
                ctx.fillRect(this.x + 4, this.y + 4 - openOffset, this.width - 8, this.height - 8);

                // Door lines (panels)
                ctx.strokeStyle = '#5c3d2e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y + 4 - openOffset);
                ctx.lineTo(this.x + this.width / 2, this.y + this.height - 4 - openOffset);
                ctx.stroke();

                // Horizontal bar
                ctx.beginPath();
                ctx.moveTo(this.x + 4, this.y + this.height / 2 - openOffset);
                ctx.lineTo(this.x + this.width - 4, this.y + this.height / 2 - openOffset);
                ctx.stroke();

                // Handle glow when opening
                if (this.opening && this.openProgress < 1) {
                    ctx.fillStyle = `rgba(0, 255, 200, ${0.5 - this.openProgress * 0.5})`;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        // Wind Switch (Trigger)
        class WindSwitch {
            constructor(x, y, width, height, targetId = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.active = false;
                this.targetId = targetId; // ID of object this switch controls (e.g. a door)
                this.spin = 0;
            }

            update(dt) {
                if (this.active) {
                    this.spin += dt * 10;
                    if (this.spin > Math.PI * 2) this.spin -= Math.PI * 2;
                }
            }

            draw(ctx) {
                // Base
                ctx.fillStyle = '#444';
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Sensor / Fan
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                if (this.active) {
                    ctx.rotate(this.spin);
                    ctx.fillStyle = '#0ff'; // Bright Cyan
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0ff';
                } else {
                    ctx.fillStyle = '#555'; // Inactive
                    // Slow idle spin
                    ctx.rotate(Date.now() / 1000);
                }

                // Draw simple fan blades
                ctx.fillRect(-15, -4, 30, 8);
                ctx.fillRect(-4, -15, 8, 30);

                // Center hub
                ctx.fillStyle = this.active ? '#fff' : '#888';
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Border
                ctx.strokeStyle = this.active ? '#fff' : '#888';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }

        // Hard Block - v1.1 New Entity
        // Can be switched by GirlButton to become blowable
        class HardBlock {
            constructor(x, y, width, height, id = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.id = id;
                this.blocked = true;
                this.switchable = false;
                this.opacity = 1.0;

                // Shatter parts
                this.parts = [];
                const cols = 3, rows = 3;
                const partW = width / cols, partH = height / rows;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        this.parts.push({
                            ox: c * partW, oy: r * partH,
                            w: partW - 2, h: partH - 2,
                            vx: 0, vy: 0
                        });
                    }
                }
            }

            makeSwitchable() {
                this.switchable = true;
                audioSystem.playSwitch();
            }

            checkWind(wind) {
                if (!this.switchable || !this.blocked || !wind.active) return false;

                const toBlockX = this.x + this.width / 2 - wind.x;
                const toBlockY = this.y + this.height / 2 - wind.y;
                const distance = Math.sqrt(toBlockX * toBlockX + toBlockY * toBlockY);

                if (distance < 200) {
                    const dot = (toBlockX * wind.direction.x + toBlockY * wind.direction.y) / distance;
                    if (dot > 0.6) {
                        this.blocked = false;
                        particles.spawn(this.x + this.width / 2, this.y + this.height / 2, 'dust', 10);
                        if (window.gameManager) window.gameManager.envVersion++;
                        return true;
                    }
                }
                return false;
            }

            draw(ctx) {
                if (!this.blocked && this.opacity <= 0) return;

                if (this.blocked) {
                    // Metallic/tech style to match game aesthetic
                    const baseColor = this.switchable ? '#4a5568' : '#1a1d24';
                    const highlightColor = this.switchable ? '#718096' : '#2d3748';
                    const glowColor = this.switchable ? '#6ee7b7' : '#4b5563';

                    // Draw parts with gradient
                    for (let p of this.parts) {
                        const gradient = ctx.createLinearGradient(
                            this.x + p.ox, this.y + p.oy,
                            this.x + p.ox, this.y + p.oy + p.h
                        );
                        gradient.addColorStop(0, highlightColor);
                        gradient.addColorStop(0.3, baseColor);
                        gradient.addColorStop(1, '#0f1419');

                        ctx.fillStyle = gradient;
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);

                        // Inner shadow
                        ctx.fillStyle = 'rgba(0,0,0,0.4)';
                        ctx.fillRect(this.x + p.ox + 2, this.y + p.oy + 2, p.w - 4, 2);
                    }

                    // Main border
                    ctx.strokeStyle = glowColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x + 1, this.y + 1, this.width - 2, this.height - 2);

                    // Energy glow when switchable
                    if (this.switchable) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#6ee7b7';
                        ctx.strokeStyle = '#6ee7b7';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(this.x, this.y, this.width, this.height);
                        ctx.shadowBlur = 0;

                        // Pulsing energy lines
                        const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                        ctx.strokeStyle = `rgba(110, 231, 183, ${pulse * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width * 0.2, this.y + this.height / 2);
                        ctx.lineTo(this.x + this.width * 0.8, this.y + this.height / 2);
                        ctx.stroke();
                    }

                    // ID label (smaller, subtle)
                    if (this.id) {
                        ctx.fillStyle = this.switchable ? '#6ee7b7' : '#666';
                        ctx.font = '8px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText(this.id, this.x + this.width / 2, this.y + this.height / 2 + 3);
                    }
                } else {
                    // Shatter animation
                    if (this.opacity > 0) {
                        this.opacity -= 0.02;
                        for (let p of this.parts) {
                            if (!p.vx) {
                                p.vx = (Math.random() - 0.5) * 10;
                                p.vy = (Math.random() - 0.5) * 10;
                            }
                            p.ox += p.vx;
                            p.oy += p.vy;
                            ctx.fillStyle = `rgba(74, 85, 104, ${this.opacity})`;
                            ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);
                        }
                    }
                }
            }
        }

        // Girl Button - v1.1 New Entity
        // Only triggered by Girl, not wind
        class GirlButton {
            constructor(x, y, width, height, targetId = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.targetId = targetId;
                this.pressed = false;
            }

            checkGirl(girl) {
                if (this.pressed || !girl) return;

                // AABB collision
                if (girl.x < this.x + this.width &&
                    girl.x + GIRL_SIZE > this.x &&
                    girl.y < this.y + this.height &&
                    girl.y + GIRL_SIZE > this.y) {

                    this.pressed = true;
                    audioSystem.playButtonPress(); // Custom button sound

                    // Find and trigger target Hard Block
                    const target = hardBlocks.find(hb => hb.id === this.targetId);
                    if (target) {
                        target.makeSwitchable();
                        if (window.gameManager) window.gameManager.envVersion++;
                    }
                }
            }

            draw(ctx) {
                // Tech-style pressure plate
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                const radius = this.width * 0.35;

                // Outer ring (floor level)
                const outerGradient = ctx.createRadialGradient(centerX, centerY, radius * 0.5, centerX, centerY, radius * 1.2);
                outerGradient.addColorStop(0, 'rgba(45, 55, 72, 0.6)');
                outerGradient.addColorStop(1, 'rgba(26, 32, 44, 0.2)');

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 1.2, 0, Math.PI * 2);
                ctx.fillStyle = outerGradient;
                ctx.fill();

                // Main button
                const buttonY = this.pressed ? centerY + 2 : centerY;
                const buttonGradient = ctx.createRadialGradient(
                    centerX, buttonY - 5, 0,
                    centerX, buttonY, radius
                );

                if (this.pressed) {
                    buttonGradient.addColorStop(0, '#34d399');
                    buttonGradient.addColorStop(0.7, '#10b981');
                    buttonGradient.addColorStop(1, '#059669');
                } else {
                    buttonGradient.addColorStop(0, '#4b5563');
                    buttonGradient.addColorStop(0.7, '#374151');
                    buttonGradient.addColorStop(1, '#1f2937');
                }

                ctx.beginPath();
                ctx.arc(centerX, buttonY, radius, 0, Math.PI * 2);
                ctx.fillStyle = buttonGradient;
                ctx.fill();

                // Highlight
                ctx.beginPath();
                ctx.arc(centerX, buttonY - radius * 0.3, radius * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = this.pressed ? 'rgba(110, 231, 183, 0.3)' : 'rgba(156, 163, 175, 0.2)';
                ctx.fill();

                // Glow when pressed
                if (this.pressed) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#34d399';
                    ctx.strokeStyle = '#6ee7b7';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, buttonY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Border ring
                ctx.strokeStyle = this.pressed ? '#6ee7b7' : '#4b5563';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, buttonY, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Center indicator
                ctx.fillStyle = this.pressed ? '#fff' : '#6b7280';
                ctx.beginPath();
                ctx.arc(centerX, buttonY, radius * 0.2, 0, Math.PI * 2);
                ctx.fill();

                // Target ID (subtle, below button)
                if (this.targetId && !this.pressed) {
                    ctx.fillStyle = '#6b7280';
                    ctx.font = '7px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.targetId, centerX, centerY + radius * 1.8);
                }
            }
        }

        // Bell - v1.1 Wind Toy
        // Decorative, reacts to wind but no gameplay impact
        class Bell {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.swayAngle = 0;
                this.swaySpeed = 0;
                this.lastChime = 0;
            }

            checkWind(wind) {
                if (!wind.active) return;

                const dx = wind.x - (this.x + this.width / 2);
                const dy = wind.y - (this.y + this.height / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 150) {
                    const force = (1 - dist / 150) * 0.1;
                    const windDir = Math.atan2(dy, dx);
                    this.swaySpeed += Math.cos(windDir) * force;

                    // Chime on strong sway with pitch variation
                    if (Math.abs(this.swayAngle) > 0.3 && Date.now() - this.lastChime > 500) {
                        const pitch = 0.9 + Math.random() * 0.2; // Slight pitch variation
                        audioSystem.playChime(pitch);
                        this.lastChime = Date.now();

                        // Notify AI of interaction
                        if (window.gameManager) window.gameManager.envVersion++;
                    }
                }
            }

            update(dt) {
                this.swayAngle += this.swaySpeed;
                this.swaySpeed *= 0.95; // Damping
                this.swayAngle *= 0.98; // Return to center
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height * 0.2);
                ctx.rotate(this.swayAngle);

                // Wind chime style - tech aesthetic
                const chimeHeight = this.height * 0.6;
                const chimeWidth = this.width * 0.15;

                // Suspension point
                ctx.fillStyle = '#4b5563';
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();

                // Chime rods (3 vertical bars)
                const intensity = Math.abs(this.swayAngle) * 5;
                const glowAlpha = Math.min(intensity, 0.8);

                for (let i = -1; i <= 1; i++) {
                    const xOffset = i * chimeWidth * 0.8;
                    const rodHeight = chimeHeight * (1 - Math.abs(i) * 0.2);

                    // Rod gradient
                    const gradient = ctx.createLinearGradient(xOffset, 5, xOffset, rodHeight);
                    gradient.addColorStop(0, '#6b7280');
                    gradient.addColorStop(0.5, '#4fc3f7');
                    gradient.addColorStop(1, '#0288d1');

                    ctx.fillStyle = gradient;
                    roundRect(ctx, xOffset - chimeWidth / 2, 5, chimeWidth, rodHeight, 2);
                    ctx.fill();

                    // Glow when swaying
                    if (intensity > 0.1) {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#4fc3f7';
                        ctx.strokeStyle = `rgba(79, 195, 247, ${glowAlpha})`;
                        ctx.lineWidth = 2;
                        roundRect(ctx, xOffset - chimeWidth / 2, 5, chimeWidth, rodHeight, 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }

                    // Bottom cap (striker)
                    ctx.fillStyle = '#0288d1';
                    ctx.beginPath();
                    ctx.arc(xOffset, rodHeight + 5, chimeWidth * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Connecting thread
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, 5);
                ctx.stroke();

                ctx.restore();
            }
        }

        // --- LEVEL SYSTEM ---
        let LEVELS = typeof LEVELS_DATA !== 'undefined' ? LEVELS_DATA : [];

        // Ê∏∏ÊàèÁä∂ÊÄÅ
        let currentLevelIndex = 0; // 0-based index for LEVELS array
        let girl = null;
        let obstacles = [];
        let blockages = [];
        let gaps = [];
        let movables = [];
        let switches = [];
        let collectibles = [];
        let doors = [];
        let hardBlocks = [];  // v1.1
        let girlButtons = [];  // v1.1
        let bells = [];  // v1.1
        let wind = new Wind();

        // Helper to get grid position
        function getGridPos(col, row) {
            return {
                x: GRID_OFFSET_X + col * CELL_SIZE,
                y: GRID_OFFSET_Y + row * CELL_SIZE
            };
        }

        // Helper to parse grid config
        function parseGrid(config) {
            if (!config) return null;
            return getGridPos(config.col, config.row);
        }

        function loadLevel(levelId) {
            const levelData = LEVELS.find(l => l.id === levelId);
            if (!levelData) return;

            currentLevel = levelId;
            levelStartTime = Date.now(); // Record start time for animation

            obstacles = [];
            blockages = [];
            gaps = [];
            movables = [];
            switches = [];
            collectibles = [];
            doors = [];
            // v1.1 entities
            hardBlocks = [];
            girlButtons = [];
            bells = [];

            // Setup obstacles
            if (levelData.obstacles) {
                levelData.obstacles.forEach(obs => {
                    const pos = getGridPos(obs.col, obs.row);
                    obstacles.push(new Obstacle(pos.x, pos.y, CELL_SIZE, CELL_SIZE));
                });
            }

            // Setup blockages
            if (levelData.blockages) {
                levelData.blockages.forEach(blk => {
                    const pos = getGridPos(blk.col, blk.row);
                    let reveals = null;
                    if (blk.revealsPath) {
                        // Calculate waypoint center
                        const wp = getGridPos(blk.revealsPath.waypoint.col, blk.revealsPath.waypoint.row);
                        reveals = { waypoint: { x: wp.x + CELL_SIZE / 2, y: wp.y + CELL_SIZE / 2 } };
                    }

                    if (blk.type === 'regen') {
                        blockages.push(new RegeneratingBlockage(pos.x, pos.y, CELL_SIZE, CELL_SIZE, reveals));
                    } else if (blk.type === 'iron_regen') {
                        blockages.push(new IronRegenBlock(pos.x, pos.y, CELL_SIZE, CELL_SIZE, reveals));
                    } else {
                        const b = new Blockage(pos.x, pos.y, CELL_SIZE, CELL_SIZE, reveals);
                        if (blk.id) b.id = blk.id; // Assign ID for switches
                        blockages.push(b);
                    }
                });
            }

            // Setup gaps
            if (levelData.gaps) {
                levelData.gaps.forEach(gap => {
                    const pos = getGridPos(gap.col, gap.row);
                    gaps.push(new Gap(pos.x, pos.y, CELL_SIZE, CELL_SIZE));
                });
            }

            // Setup movables
            if (levelData.movables) {
                levelData.movables.forEach(mov => {
                    const pos = getGridPos(mov.col, mov.row);
                    let w = CELL_SIZE;
                    let h = CELL_SIZE;
                    movables.push(new Movable(pos.x, pos.y, w, h, mov.type));
                });
            }

            // Setup switches
            if (levelData.switches) {
                levelData.switches.forEach(sw => {
                    const pos = getGridPos(sw.col, sw.row);
                    switches.push(new WindSwitch(pos.x, pos.y, CELL_SIZE, CELL_SIZE, sw.targetId));
                });
            }

            // Setup collectibles
            collectibles = [];
            if (levelData.collectibles) {
                levelData.collectibles.forEach(col => {
                    const pos = getGridPos(col.col, col.row);
                    collectibles.push(new Collectible(pos.x, pos.y, CELL_SIZE, CELL_SIZE));
                });
            }

            // Setup doors
            doors = [];
            if (levelData.doors) {
                levelData.doors.forEach(d => {
                    const pos = getGridPos(d.col, d.row);
                    doors.push(new Door(pos.x, pos.y, CELL_SIZE, CELL_SIZE, d.id));
                });
            }

            // Setup hard blocks (v1.1)
            hardBlocks = [];
            if (levelData.hardBlocks) {
                levelData.hardBlocks.forEach(hb => {
                    const pos = getGridPos(hb.col, hb.row);
                    hardBlocks.push(new HardBlock(pos.x, pos.y, CELL_SIZE, CELL_SIZE, hb.id));
                });
            }

            // Setup girl buttons (v1.1)
            girlButtons = [];
            if (levelData.girlButtons) {
                levelData.girlButtons.forEach(gb => {
                    const pos = getGridPos(gb.col, gb.row);
                    girlButtons.push(new GirlButton(pos.x, pos.y, CELL_SIZE, CELL_SIZE, gb.targetId));
                });
            }

            // Setup bells (v1.1)
            bells = [];
            if (levelData.bells) {
                levelData.bells.forEach(b => {
                    const pos = getGridPos(b.col, b.row);
                    bells.push(new Bell(pos.x, pos.y, CELL_SIZE, CELL_SIZE));
                });
            }

            // Setup Girl
            const startPos = getGridPos(levelData.gridStart.col, levelData.gridStart.row);
            const goalPos = getGridPos(levelData.gridExit.col, levelData.gridExit.row);

            girl = new Girl(startPos.x + (CELL_SIZE - GIRL_SIZE) / 2, startPos.y + (CELL_SIZE - GIRL_SIZE) / 2, goalPos);
        }

        // --- LEVEL EDITOR ---
        class LevelEditor {
            constructor() {
                this.active = false;
                this.grid = Array(GRID_H).fill(null).map(() => Array(GRID_W).fill(0));
                this.startPos = { col: 0, row: 1 };
                this.exitPos = { col: 3, row: 1 };

                // 0: Empty, 1: Obstacle, 2: Block(Static), 3: Block(Regen)
                // 4: Gap, 5: Plank, 6: Switch, 7: Start, 8: Exit
                // 9: Collectible, 10: Door
                // 11: HardBlock, 12: GirlButton, 13: Bell (v1.1)
                // 14: IronRegenBlock (v1.1)
                this.selectedType = 1;
                this.typeNames = ["Clear", "Obstacle", "Block(Static)", "Block(Regen)", "Gap", "Plank", "Switch", "Start", "Exit", "Col", "Door", "HardBlock", "GirlBtn", "Bell", "IronRegen"];

                // v1.1: Linking system for GirlButton -> HardBlock
                this.linkMode = false;
                this.linkSource = null; // {col, row, type}
            }

            toggle() {
                this.active = !this.active;
                if (this.active) {
                    // Try to populate grid from current level? 
                    // For simplicity, start clean or keep editor state.
                    // (Advanced: Parse current objects back to grid)
                }
            }

            handleClick(x, y) {
                if (!this.active) return;

                // Convert screen to grid
                let col = Math.floor((x - GRID_OFFSET_X) / CELL_SIZE);
                let row = Math.floor((y - GRID_OFFSET_Y) / CELL_SIZE);

                if (col >= 0 && col < GRID_W && row >= 0 && row < GRID_H) {
                    if (this.selectedType === 7) {
                        this.startPos = { col, row };
                    } else if (this.selectedType === 8) {
                        this.exitPos = { col, row };
                    } else {
                        // Toggle or set?
                        this.grid[row][col] = this.selectedType;
                    }
                }
            }

            draw(ctx) {
                if (!this.active) return;

                // Dark overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // Draw Grid
                ctx.save();
                ctx.translate(GRID_OFFSET_X, GRID_OFFSET_Y);

                for (let r = 0; r < GRID_H; r++) {
                    for (let c = 0; c < GRID_W; c++) {
                        const val = this.grid[r][c];
                        const x = c * CELL_SIZE;
                        const y = r * CELL_SIZE;

                        // Border
                        ctx.strokeStyle = '#555';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);

                        // Content
                        if (r === this.startPos.row && c === this.startPos.col) {
                            ctx.fillStyle = '#f0f'; ctx.fillText("START", x + 10, y + 40);
                        }
                        if (r === this.exitPos.row && c === this.exitPos.col) {
                            ctx.fillStyle = '#ff0'; ctx.fillText("EXIT", x + 15, y + 40);
                        }

                        if (val === 1) { ctx.fillStyle = '#888'; ctx.fillRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10); }
                        if (val === 2) { ctx.fillStyle = '#f88'; ctx.fillRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10); ctx.fillStyle = '#000'; ctx.fillText("BLK", x + 10, y + 20); }
                        if (val === 3) { ctx.fillStyle = '#f44'; ctx.fillRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10); ctx.fillStyle = '#000'; ctx.fillText("REG", x + 10, y + 20); }
                        if (val === 4) { ctx.fillStyle = '#000'; ctx.fillRect(x + 10, y + 10, CELL_SIZE - 20, CELL_SIZE - 20); } // Gap
                        if (val === 5) { ctx.fillStyle = '#44f'; ctx.fillRect(x + 15, y + 50, CELL_SIZE - 30, 20); } // Plank
                        if (val === 6) { ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, 10, 0, Math.PI * 2); ctx.fill(); } // Switch
                        if (val === 9) { ctx.fillStyle = '#ffcc00'; ctx.beginPath(); ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, 8, 0, Math.PI * 2); ctx.fill(); } // Collectible
                        if (val === 10) {
                            ctx.fillStyle = '#7b5544'; ctx.fillRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10);
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10);
                            ctx.fillStyle = '#fff'; ctx.font = '10px Arial'; ctx.fillText("D", x + 15, y + 25);
                        } // Door
                        if (val === 11) { // HardBlock
                            ctx.fillStyle = '#2d2d2d'; ctx.fillRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10);
                            ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.strokeRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10);
                            ctx.fillStyle = '#fff'; ctx.font = '9px Arial'; ctx.fillText("HB", x + 10, y + 22);
                        }
                        if (val === 12) { // GirlButton
                            ctx.fillStyle = '#888'; ctx.beginPath(); ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, 12, 0, Math.PI * 2); ctx.fill();
                            ctx.strokeStyle = '#aaa'; ctx.lineWidth = 3; ctx.stroke();
                            ctx.fillStyle = '#fff'; ctx.font = '9px Arial'; ctx.fillText("GB", x + CELL_SIZE / 2 - 8, y + CELL_SIZE / 2 + 3);
                        }
                        if (val === 13) { // Bell
                            ctx.save();
                            ctx.translate(x + CELL_SIZE / 2, y + CELL_SIZE / 4);
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.moveTo(0, CELL_SIZE * 0.2);
                            ctx.lineTo(-CELL_SIZE * 0.15, CELL_SIZE * 0.5);
                            ctx.lineTo(CELL_SIZE * 0.15, CELL_SIZE * 0.5);
                            ctx.closePath();
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                }
                ctx.restore();

                // HUD
                ctx.fillStyle = '#fff';
                ctx.font = '16px Monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`EDITOR MODE [E] to Close`, 20, 30);
                ctx.fillText(`Selected: [${this.selectedType}] ${this.typeNames[this.selectedType]}`, 20, 50);
                ctx.fillText(`Keys: 0-Clear, 1-Obs, 2-Stat, 3-Reg, 4-Gap, 5-Plank`, 20, 70);
                ctx.fillText(`      6-Sw, 7-Start, 8-Exit, 9-Col, D-Door`, 20, 90);
                ctx.fillText(`      H-HardBlock, G-GirlBtn, B-Bell, I-IronRegen`, 20, 110);
                ctx.fillText(`[P] Print Config   [L] Link Mode ${this.linkMode ? 'ON' : 'OFF'}`, 20, 130);
            }

            exportConfig() {
                // Generate JSON
                let config = {
                    id: LEVELS.length + 1,
                    gridStart: this.startPos,
                    gridExit: this.exitPos,
                    obstacles: [],
                    blockages: [],
                    gaps: [],
                    movables: [],
                    switches: [],
                    collectibles: [],
                    doors: [],
                    hardBlocks: [],      // v1.1
                    girlButtons: [],     // v1.1
                    bells: []            // v1.1
                };

                let switchCount = 0;
                let blockCount = 0;
                let doorCount = 0;
                let hardBlockCount = 0;
                let girlButtonCount = 0;

                for (let r = 0; r < GRID_H; r++) {
                    for (let c = 0; c < GRID_W; c++) {
                        const val = this.grid[r][c];
                        if (val === 1) config.obstacles.push({ col: c, row: r });
                        if (val === 2) {
                            blockCount++;
                            config.blockages.push({ col: c, row: r, type: 'static', id: blockCount });
                        }
                        if (val === 3) config.blockages.push({ col: c, row: r, type: 'regen' });
                        if (val === 14) config.blockages.push({ col: c, row: r, type: 'iron_regen' });
                        if (val === 4) config.gaps.push({ col: c, row: r });
                        if (val === 5) config.movables.push({ col: c, row: r, type: 'plank' });
                        if (val === 6) {
                            config.switches.push({ col: c, row: r, targetId: 1 }); // Default link to ID 1
                        }
                        if (val === 9) config.collectibles.push({ col: c, row: r });
                        if (val === 10) {
                            doorCount++;
                            config.doors.push({ col: c, row: r, id: doorCount });
                        }
                        if (val === 11) {
                            hardBlockCount++;
                            config.hardBlocks.push({ col: c, row: r, id: `hb${hardBlockCount}` });
                        }
                        if (val === 12) {
                            girlButtonCount++;
                            config.girlButtons.push({ col: c, row: r, targetId: `hb1` }); // Default link to hb1
                        }
                        if (val === 13) {
                            config.bells.push({ col: c, row: r });
                        }
                    }
                }

                const json = JSON.stringify(config, null, 2);
                console.log(json);
                window.alert("Config copied to clipboard (hypothetically) / Check Console!\n" + JSON.stringify(config));
                // Try copy
                try { navigator.clipboard.writeText(json); } catch (e) { }
            }
        }

        // ===============================
        // CORE SYSTEM (Save & Manager)
        // ===============================
        class SaveSystem {
            static save(levelId, collectedStars = 0) {
                console.log(`Saving progress: Level ${levelId}, Stars: ${collectedStars}`);
                const data = this.load();
                if (levelId > data.maxLevel) {
                    data.maxLevel = levelId;
                }
                if (!data.stars[levelId]) data.stars[levelId] = 0;
                if (collectedStars > data.stars[levelId]) {
                    data.stars[levelId] = collectedStars;
                }
                localStorage.setItem('windy_save_v1', JSON.stringify(data));
            }

            static load() {
                try {
                    const raw = localStorage.getItem('windy_save_v1');
                    if (raw) {
                        const data = JSON.parse(raw);
                        // Validate and ensure defaults
                        if (!data.maxLevel) data.maxLevel = 1;
                        if (!data.stars) data.stars = {};
                        return data;
                    }
                } catch (e) {
                    console.error("Save load failing, resetting", e);
                }
                return { maxLevel: 1, stars: {} };
            }

            static reset() {
                localStorage.removeItem('windy_save_v1');
                location.reload();
            }
        }

        class GameManager {
            constructor() {
                this.state = 'MENU'; // MENU, LEVEL_SELECT, PLAYING, TRANSITION
                this.isMuted = false;
                this.currentLevelId = 1;
                this.envVersion = 0; // Track environment changes for AI expressions

                // UI Elements
                this.screens = {
                    start: document.getElementById('start-screen'),
                    gallery: document.getElementById('level-gallery'),
                    hud: document.getElementById('hud'),
                    grid: document.getElementById('level-grid'),
                    transition: document.getElementById('transition-overlay')
                };

                this.elements = {
                    levelDisplay: document.getElementById('hud-level-display'),
                    starIcon: document.getElementById('hud-star'),
                    btnMute: document.getElementById('btn-mute'),
                    btnReset: document.getElementById('btn-reset'),
                    btnHome: document.getElementById('btn-home')
                };

                this._bindEvents();
                this._initGallery();
            }

            init() {
                this.switchState('MENU');
            }

            _bindEvents() {
                document.getElementById('btn-start').onclick = () => {
                    const save = SaveSystem.load();
                    this.startLevel(save.maxLevel > LEVELS.length ? LEVELS.length : save.maxLevel);
                };

                document.getElementById('btn-levels').onclick = () => {
                    this._updateGallery();
                    this.switchState('LEVEL_SELECT');
                };

                document.getElementById('btn-back-menu').onclick = () => this.switchState('MENU');

                // HUD Controls
                this.elements.btnReset.onclick = () => loadLevel(this.currentLevelId); // Reuse global loadLevel
                this.elements.btnHome.onclick = () => this.switchState('MENU');
                this.elements.btnMute.onclick = () => this.toggleMute();
            }

            _initGallery() {
                this.screens.grid.innerHTML = '';
                // Create placeholders for max 20 levels
                for (let i = 1; i <= 20; i++) {
                    const btn = document.createElement('div');
                    btn.className = 'level-btn locked';
                    btn.innerText = i;

                    const starMark = document.createElement('div');
                    starMark.className = 'star-mark';
                    starMark.innerText = '‚òÖ';
                    btn.appendChild(starMark);

                    btn.onclick = () => {
                        if (btn.classList.contains('locked')) return;
                        this.startLevel(i);
                    };

                    this.screens.grid.appendChild(btn);
                }
            }

            _updateGallery() {
                const save = SaveSystem.load();
                const btns = this.screens.grid.children;
                for (let i = 0; i < btns.length; i++) {
                    const levelId = i + 1;
                    const btn = btns[i];

                    if (LEVELS.find(l => l.id === levelId)) {
                        // Level exists
                        if (levelId <= save.maxLevel) {
                            btn.className = 'level-btn';
                            if (save.stars[levelId]) btn.classList.add('collected');
                            else btn.classList.remove('collected');
                        } else {
                            btn.className = 'level-btn locked';
                            btn.classList.remove('collected');
                        }
                    } else {
                        // Level doesn't exist yet
                        btn.className = 'level-btn locked';
                        btn.style.opacity = '0.1';
                    }
                }
            }

            startLevel(id) {
                if (!LEVELS.find(l => l.id === id)) {
                    console.error("Level ID not found:", id);
                    return;
                }

                console.log("Starting Level:", id);
                this.currentLevelId = id;
                // Transition
                this.screens.transition.style.opacity = 1;

                setTimeout(() => {
                    loadLevel(id); // Global load
                    this.switchState('PLAYING');
                    this.screens.transition.style.opacity = 0;

                    // Update HUD
                    this.elements.levelDisplay.innerText = "LEVEL " + id;
                    this.elements.starIcon.classList.remove('active');
                }, 500);
            }

            completeLevel(starsCollected = 0) {
                // Save
                SaveSystem.save(this.currentLevelId + 1, starsCollected);

                // Transition
                this.state = 'TRANSITION';
                this.screens.transition.style.opacity = 1;

                setTimeout(() => {
                    const nextId = this.currentLevelId + 1;
                    if (LEVELS.find(l => l.id === nextId)) {
                        this.startLevel(nextId);
                    } else {
                        // Finished all levels
                        this.switchState('MENU');
                        this.screens.transition.style.opacity = 0;
                        alert("CONGRATULATIONS! You completed all levels!");
                    }
                }, 1000);
            }

            switchState(newState) {
                this.state = newState;
                // Hide all screens
                Object.values(this.screens).forEach(s => {
                    if (s && s.classList.contains('screen')) s.classList.remove('active');
                });
                this.screens.hud.style.display = 'none';

                if (newState === 'MENU') {
                    this.screens.start.classList.add('active');
                    // Reset game entities so they don't interfere
                    // girl = null; 
                    // Actually, keep running background demo?
                } else if (newState === 'LEVEL_SELECT') {
                    this.screens.gallery.classList.add('active');
                } else if (newState === 'PLAYING') {
                    this.screens.hud.style.display = 'block';
                }
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                this.elements.btnMute.innerText = this.isMuted ? 'üîá' : 'üîä';
                if (audioSystem && audioSystem.masterGain) {
                    audioSystem.masterGain.gain.setValueAtTime(this.isMuted ? 0 : 0.5, audioSystem.ctx.currentTime);
                }
            }

            updateHUD(starsCount) {
                if (starsCount > 0) this.elements.starIcon.classList.add('active');
                else this.elements.starIcon.classList.remove('active');
            }
        }

        const gameManager = new GameManager();
        window.gameManager = gameManager; // Expose for envVersion check in Girl class

        const editor = new LevelEditor();

        // Init Game
        gameManager.init();

        // Input Handling

        // Track active wind keys
        const activeKeys = new Set();

        window.addEventListener('keydown', (e) => {
            // Init audio context on first interaction
            if (!audioSystem.isInit) audioSystem.init();

            const key = e.key.toLowerCase();

            // Level Controls
            if (key === 'r') {
                loadLevel(currentLevel);
                return;
            }
            if (key === 'e') {
                editor.toggle();
                return;
            }
            if (editor.active) {
                if (key === 'p') editor.exportConfig();
                if (key >= '0' && key <= '9') editor.selectedType = parseInt(key);
                if (key === 'd') editor.selectedType = 10;
                if (key === 'h') editor.selectedType = 11; // HardBlock
                if (key === 'g') editor.selectedType = 12; // GirlButton
                if (key === 'b') editor.selectedType = 13; // Bell
                if (key === 'l') {
                    editor.linkMode = !editor.linkMode;
                    if (!editor.linkMode) editor.linkSource = null;
                }
                return;
            }

            if (key >= '1' && key <= '9') {
                const id = parseInt(key);
                if (LEVELS.find(l => l.id === id)) loadLevel(id);
                return;
            }
            // N = Next level, P = Previous level
            if (key === 'n') {
                const nextLevel = currentLevel + 1;
                if (LEVELS.find(l => l.id === nextLevel)) loadLevel(nextLevel);
                return;
            }
            if (key === 'p' && !editor.active) {
                const prevLevel = currentLevel - 1;
                if (LEVELS.find(l => l.id === prevLevel)) loadLevel(prevLevel);
                return;
            }

            // Wind Controls (WASD)
            if (['w', 'a', 's', 'd'].includes(key)) {
                if (!activeKeys.has(key)) {
                    activeKeys.add(key);
                    wind.setDirection(key);
                    wind.activate();
                    wind.checkBlockages(blockages);
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();

            if (['w', 'a', 's', 'd'].includes(key)) {
                activeKeys.delete(key);
                if (activeKeys.size === 0) {
                    wind.stop();
                } else {
                    // Update direction to remaining key (optional, simplistic)
                    const lastKey = Array.from(activeKeys).pop();
                    wind.setDirection(lastKey);
                }
            }
        });

        // Mouse Move & Click
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let mouseX = (e.clientX - rect.left) * scaleX;
            let mouseY = (e.clientY - rect.top) * scaleY;
            wind.setPosition(mouseX, mouseY);
        });

        canvas.addEventListener('mousedown', (e) => {
            // Init audio context on first interaction
            if (!audioSystem.isInit) audioSystem.init();

            if (editor.active) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                let mouseX = (e.clientX - rect.left) * scaleX;
                let mouseY = (e.clientY - rect.top) * scaleY;
                editor.handleClick(mouseX, mouseY);
            }
        });

        // Initialize
        loadLevel(1);
        requestAnimationFrame(gameLoop);

        // Ê∏∏ÊàèÂæ™ÁéØ
        let lastTime = Date.now();

        function gameLoop() {
            const now = Date.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            // Always update particles + audio for dynamic background in menu
            particles.update(dt);
            wind.draw(ctx); // Just draw wind cursor logic if needed, but maybe hide?
            // Actually wind needs update for drawing cursor

            ctx.fillStyle = THEME.bg;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            if (gameManager.state === 'MENU' || gameManager.state === 'LEVEL_SELECT') {
                // Background animation only
                particles.draw(ctx);

                // Draw wind stream demo if mouse moves
                // (Let standard draw calls handle it below if we skip game logic)
                wind.draw(ctx);

                // Vignette
                const gradient = ctx.createRadialGradient(
                    GAME_WIDTH / 2, GAME_HEIGHT / 2, 200,
                    GAME_WIDTH / 2, GAME_HEIGHT / 2, 500
                );
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                requestAnimationFrame(gameLoop);
                return;
            }

            if (gameManager.state === 'PLAYING' || gameManager.state === 'TRANSITION') {
                // Updates
                for (let obj of movables) obj.update(dt);
                for (let blk of blockages) blk.update(dt);
                for (let door of doors) door.update(dt);
                for (let bell of bells) bell.update(dt); // v1.1

                for (let s of switches) {
                    s.update(dt);
                    if (s.active && s.targetId) {
                        const door = doors.find(d => d.id === s.targetId);
                        if (door && !door.opening) door.open();
                    }
                }
                for (let gap of gaps) gap.checkFilled(movables);

                const unlockedMovables = movables.filter(m => !m.isLocked);
                const blockedDoors = doors.filter(d => d.blocked);
                const blockedHardBlocks = hardBlocks.filter(hb => hb.blocked); // v1.1

                if (girl) {
                    girl.update(dt,
                        obstacles.concat(unlockedMovables).concat(blockedDoors).concat(blockedHardBlocks),
                        blockages, gaps, switches, collectibles, hardBlocks, girlButtons);

                    // Check girl buttons (v1.1)
                    for (let gb of girlButtons) gb.checkGirl(girl);
                }

                // Update collectibles
                for (let col of collectibles) col.update(dt, girl);

                // Update wind fatigue
                if (wind.active) {
                    windFatigue += FATIGUE_RATE * dt;
                    if (windFatigue > 100) windFatigue = 100;

                    wind.pushMovables(movables);
                    wind.checkBlockages(blockages);
                    wind.checkSwitches(switches);

                    // Check hard blocks (v1.1)
                    for (let hb of hardBlocks) hb.checkWind(wind);

                    // Check bells (v1.1)
                    for (let bell of bells) bell.checkWind(wind);
                } else {
                    windFatigue -= RECOVERY_RATE * dt;
                    if (windFatigue < 0) windFatigue = 0;
                }

                // Check Win Condition (Girl reached goal)
                // Check Win Condition (Girl reached goal)
                // Check Win Condition (Girl reached goal)
                if (girl && girl.state === 'REACHED_GOAL') {
                    if (!girl.celebrating) {
                        girl.celebrating = true;

                        // Play win sound immediately
                        if (audioSystem) audioSystem.playWin();

                        // Delay dissolve to show happy expression
                        setTimeout(() => {
                            if (girl) girl.dissolved = true;
                            // Spawn particles
                            for (let i = 0; i < 30; i++) {
                                particles.spawn(girl.x + GIRL_SIZE / 2, girl.y + GIRL_SIZE / 2, '#fff');
                                particles.spawn(girl.x + GIRL_SIZE / 2, girl.y + GIRL_SIZE / 2, '#fc0');
                            }
                        }, 800);

                        // Delay completion
                        setTimeout(() => {
                            const starsCollected = collectibles.filter(c => c.collected).length;
                            if (gameManager.state !== 'TRANSITION') {
                                gameManager.completeLevel(starsCollected);
                            }
                        }, 1800);
                    }
                }

                // Update HUD Stars
                const currentStars = collectibles.filter(c => c.collected).length;
                gameManager.updateHUD(currentStars);
            }

            // Draw Everything
            if (editor.active) {
                editor.draw(ctx);
                requestAnimationFrame(gameLoop);
                return;
            }


            // Update Shake
            if (shakeIntensity > 0) {
                shakeIntensity -= dt * 60;
                if (shakeIntensity < 0) shakeIntensity = 0;
            }

            // Draw Grid
            ctx.save();

            // Apply Shake to World
            if (shakeIntensity > 0) {
                const rx = (Math.random() - 0.5) * shakeIntensity;
                const ry = (Math.random() - 0.5) * shakeIntensity;
                ctx.translate(rx, ry);
            }

            ctx.translate(GRID_OFFSET_X, GRID_OFFSET_Y);

            // Pop-up Animation
            const timeSinceLoad = (Date.now() - levelStartTime) / 1000;

            for (let r = 0; r < GRID_H; r++) {
                for (let c = 0; c < GRID_W; c++) {
                    let scale = 1;
                    // Animation logic
                    if (timeSinceLoad < 2.0 && levelStartTime > 0) {
                        const delay = (c + r) * 0.05;
                        const t = Math.max(0, Math.min((timeSinceLoad - delay) * 4, 1));
                        // Ease Out Back
                        const c1 = 1.70158;
                        const c3 = c1 + 1;
                        scale = 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
                        if (t <= 0) scale = 0;
                        if (t >= 1) scale = 1;
                    }

                    if (scale > 0.01) {
                        ctx.save();
                        const cx = c * CELL_SIZE + CELL_SIZE / 2;
                        const cy = r * CELL_SIZE + CELL_SIZE / 2;
                        ctx.translate(cx, cy);
                        ctx.scale(scale, scale);

                        ctx.fillStyle = THEME.grid;
                        ctx.fillRect(-CELL_SIZE / 2 + 1, -CELL_SIZE / 2 + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                        ctx.restore();
                    }
                }
            }

            ctx.restore();

            // 3. Draw Entities
            ctx.save();
            ctx.translate(shakeX, shakeY);

            // Exit Marker (New) - Use FINAL GOAL
            if (girl) {
                // Determine exit position (goal)
                // Draw a glowing floor plate
                ctx.save();
                // Use finalGoalX/Y instead of goalX/Y which changes
                const exitX = girl.finalGoalX + GIRL_SIZE / 2;
                const exitY = girl.finalGoalY + GIRL_SIZE / 2;
                const exitRadius = 30 + Math.sin(now / 500) * 5;

                // Outer Glow
                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.2)'; // Warm Orange/Yellow
                ctx.fill();

                // Inner Core (Restored)
                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.4)';
                ctx.fill();

                // Light Beam (Restored Gradient)
                const grad = ctx.createLinearGradient(exitX, exitY, exitX, exitY - 150);
                grad.addColorStop(0, 'rgba(255, 170, 51, 0.3)');
                grad.addColorStop(1, 'rgba(255, 170, 51, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(exitX - 20, exitY);
                ctx.lineTo(exitX + 20, exitY);
                ctx.lineTo(exitX + 30, exitY - 150);
                ctx.lineTo(exitX - 30, exitY - 150);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }

            for (let gap of gaps) gap.draw(ctx);
            for (let obs of obstacles) obs.draw(ctx);
            for (let blk of blockages) blk.draw(ctx);
            for (let door of doors) door.draw(ctx);
            for (let hb of hardBlocks) hb.draw(ctx); // v1.1
            for (let gb of girlButtons) gb.draw(ctx); // v1.1
            for (let mov of movables) mov.draw(ctx);
            for (let sw of switches) sw.draw(ctx);
            for (let col of collectibles) col.draw(ctx);
            for (let bell of bells) bell.draw(ctx); // v1.1

            if (girl && !girl.dissolved) girl.draw(ctx);
            wind.draw(ctx);
            particles.draw(ctx);
            ctx.restore();

            // 6. Lighting / Vignette Overlay
            const gradient = ctx.createRadialGradient(
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 200,
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 500
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            requestAnimationFrame(gameLoop);
        }

        // ÂêØÂä®Ê∏∏Êàè
        gameLoop();
    </script>
</body>

</html>