<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>女孩与风 - 原型v1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ddd;
            height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            background: #1a1b1e;
            display: block;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            pointer-events: none;
            backdrop-filter: blur(5px);
            border-left: 2px solid #ff6b9d;
        }

        .controls div {
            margin-bottom: 5px;
            font-size: 13px;
            color: #aaa;
        }

        .controls strong {
            color: #fff;
            display: block;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            left: 30px;
            font-size: 24px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            letter-spacing: 2px;
        }

        .debug {
            display: none;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="level-indicator" id="levelIndicator">LEVEL 1</div>
        <div class="controls">
            <div><strong>Controls</strong></div>
            <div>MOUSE - Move Wind Source</div>
            <div>HOLD W/A/S/D - Blow Wind</div>
            <div>R - Restart Level</div>
            <div>1/2 - Switch Level</div>
        </div>
    </div>

    <div class="debug" id="debugInfo"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelIndicator = document.getElementById('levelIndicator');

        // Visual Style Constants
        const THEME = {
            bg: '#1a1b1e',
            grid: '#232428',
            wall: '#2a2b30',
            highlight: '#3a3b40',
            girl: '#ff6b9d',
            girlShadow: '#b03055',
            obstacle: '#333333',
            obstacleHighlight: '#444444',
            plank: '#cba', // Light minimalist wood/block
            plankShadow: '#876',
            wind: '#4ff',
            exit: '#44ffaa',
            gap: '#151619' // Slightly darker than BG
        };

        // Grid System
        const CELL_SIZE = 80;
        const GRID_W = 4;
        const GRID_H = 4;
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;

        // Calculate Grid Offset to center it
        const GRID_OFFSET_X = (GAME_WIDTH - (GRID_W * CELL_SIZE)) / 2;
        const GRID_OFFSET_Y = (GAME_HEIGHT - (GRID_H * CELL_SIZE)) / 2;

        // Configuration
        const GIRL_SIZE = 40; // Smaller relative to cell (half size) for "small" feel
        const GIRL_SPEED = 150; // Adjusted for larger scale


        // Helper for rounded rectangles
        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            return ctx;
        }

        // Particle System
        class Particle {
            constructor(x, y, type = 'dust') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1.0;

                if (type === 'dust') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    this.decay = 0.005 + Math.random() * 0.01;
                    this.size = 1 + Math.random() * 2;
                    this.color = `rgba(255, 255, 255, ${0.05 + Math.random() * 0.1})`;
                } else if (type === 'wind') {
                    this.vx = 0;
                    this.vy = 0;
                    this.decay = 0.02 + Math.random() * 0.03;
                    this.size = 2 + Math.random() * 3;
                    this.color = '#4ff';
                }
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= this.decay;
            }

            draw(ctx) {
                if (this.life <= 0) return;

                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;

                if (this.type === 'wind') {
                    ctx.fillStyle = THEME.wind;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            spawn(x, y, type, count = 1) {
                for (let i = 0; i < count; i++) {
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    this.particles.push(new Particle(x + offsetX, y + offsetY, type));
                }
            }

            update(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.update(dt);
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }

                // Always spawn background dust
                if (Math.random() < 0.2) {
                    this.spawn(
                        Math.random() * GAME_WIDTH,
                        Math.random() * GAME_HEIGHT,
                        'dust'
                    );
                }
            }

            draw(ctx) {
                for (let p of this.particles) {
                    p.draw(ctx);
                }
            }
        }

        const particles = new ParticleSystem();

        // ===============================
        // GRID-BASED BFS PATHFINDING
        // ===============================

        // 将像素坐标转换为网格坐标
        function pixelToGrid(x, y) {
            const col = Math.floor((x - GRID_OFFSET_X) / CELL_SIZE);
            const row = Math.floor((y - GRID_OFFSET_Y) / CELL_SIZE);
            return {
                col: Math.max(0, Math.min(GRID_W - 1, col)),
                row: Math.max(0, Math.min(GRID_H - 1, row))
            };
        }

        // 将网格坐标转换为像素坐标（格子中心，调整为女孩位置）
        function gridToPixel(col, row) {
            return {
                x: GRID_OFFSET_X + col * CELL_SIZE + (CELL_SIZE - GIRL_SIZE) / 2,
                y: GRID_OFFSET_Y + row * CELL_SIZE + (CELL_SIZE - GIRL_SIZE) / 2
            };
        }

        // 检查某个格子是否可通行
        function isGridCellWalkable(col, row, obstacles, blockages, gaps, ignoreEntities = []) {
            if (col < 0 || col >= GRID_W || row < 0 || row >= GRID_H) return false;

            const cellX = GRID_OFFSET_X + col * CELL_SIZE;
            const cellY = GRID_OFFSET_Y + row * CELL_SIZE;

            // 检查障碍物
            for (let obs of obstacles) {
                if (ignoreEntities.includes(obs)) continue;
                if (cellX < obs.x + obs.width &&
                    cellX + CELL_SIZE > obs.x &&
                    cellY < obs.y + obs.height &&
                    cellY + CELL_SIZE > obs.y) {
                    return false;
                }
            }

            // 检查 blockages（只有 blocked 状态才阻挡）
            for (let b of blockages) {
                if (ignoreEntities.includes(b)) continue;
                if (b.blocked) {
                    if (cellX < b.x + b.width &&
                        cellX + CELL_SIZE > b.x &&
                        cellY < b.y + b.height &&
                        cellY + CELL_SIZE > b.y) {
                        return false;
                    }
                }
            }

            // 检查 gaps（只有未填充的 gap 才阻挡）
            for (let g of gaps) {
                if (!g.isFilled) {
                    if (cellX < g.x + g.width &&
                        cellX + CELL_SIZE > g.x &&
                        cellY < g.y + g.height &&
                        cellY + CELL_SIZE > g.y) {
                        return false;
                    }
                }
            }

            return true;
        }

        // BFS 找最短路径，返回像素坐标数组（waypoints）
        // 如果终点不可达，返回到最接近终点的可达格子的路径
        function findGridPath(startX, startY, endX, endY, obstacles, blockages, gaps, ignoreEntities = []) {
            const start = pixelToGrid(startX, startY);
            const end = pixelToGrid(endX, endY);

            // 如果起点终点相同，直接返回
            if (start.col === end.col && start.row === end.row) {
                return [];
            }

            // 起点到终点的距离
            const startDist = Math.abs(start.col - end.col) + Math.abs(start.row - end.row);

            // BFS 队列
            const queue = [{ col: start.col, row: start.row, path: [] }];
            const visited = new Set();
            visited.add(`${start.col},${start.row}`);

            // 记录真正朝终点方向的最远位置
            let bestPath = [];
            let bestDist = startDist;

            // 四个方向
            const directions = [
                { dc: 0, dr: -1 }, { dc: 0, dr: 1 },
                { dc: -1, dr: 0 }, { dc: 1, dr: 0 }
            ];

            while (queue.length > 0) {
                const current = queue.shift();

                for (let dir of directions) {
                    const newCol = current.col + dir.dc;
                    const newRow = current.row + dir.dr;
                    const key = `${newCol},${newRow}`;

                    if (visited.has(key)) continue;
                    if (!isGridCellWalkable(newCol, newRow, obstacles, blockages, gaps, ignoreEntities)) continue;

                    visited.add(key);

                    const newPath = [...current.path, { col: newCol, row: newRow }];

                    // 找到终点！
                    if (newCol === end.col && newRow === end.row) {
                        return newPath.map(p => gridToPixel(p.col, p.row));
                    }

                    // 检查是否比当前最佳位置更接近终点
                    const dist = Math.abs(newCol - end.col) + Math.abs(newRow - end.row);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestPath = newPath;
                    }

                    queue.push({ col: newCol, row: newRow, path: newPath });
                }
            }

            // 没找到完整路径，但如果有更接近终点的位置就返回那个路径
            if (bestPath.length > 0 && bestDist < startDist) {
                return bestPath.map(p => gridToPixel(p.col, p.row));
            }

            // 无法更接近终点了
            return [];
        }

        // Girl with "Thomas Was Alone" Aesthetics
        class Girl {
            constructor(x, y, goalPos) {
                this.x = x;
                this.y = y;
                this.width = GIRL_SIZE;
                this.height = GIRL_SIZE;

                // Set explicitly from parsed goalPos
                if (goalPos) {
                    this.goalX = goalPos.x + (CELL_SIZE - GIRL_SIZE) / 2;
                    this.goalY = goalPos.y + (CELL_SIZE - GIRL_SIZE) / 2;
                } else {
                    this.goalX = GAME_WIDTH - 50;
                    this.goalY = GAME_HEIGHT / 2;
                }

                // Final Goal (The Exit) - Persistent
                this.finalGoalX = this.goalX;
                this.finalGoalY = this.goalY;

                // currentGoal is the IMMEDIATE waypoint we are walking towards
                this.currentGoalX = this.goalX;
                this.currentGoalY = this.goalY;

                // Waypoint Queue for L-Shaped movement
                this.pathQueue = [];

                this.state = 'WALKING';
                this.speed = GIRL_SPEED;
                this.color = '#ff6b9d';
                this.stateTimer = 0;

                this.stateTimer = 0;

                this.detourPath = null;
                this.hasDetoured = false;
                this.reachedWaypoint = false;
                this.stuckAtClosest = false; // 标记是否已到达最近位置

                // Animation
                this.bobOffset = 0;
                this.eyeOffset = { x: 0, y: 0 };
                this.blinkTimer = 0;
                this.expression = '';
            }



            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                roundRect(ctx, this.x + 5, this.y + 5 + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Body
                ctx.fillStyle = THEME.girl;
                roundRect(ctx, this.x, this.y + this.bobOffset, this.width, this.height, 4);
                ctx.fill();

                // Inner Highlights (Bevel effect)
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(this.x, this.y + this.bobOffset, this.width, 4);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(this.x, this.y + this.height - 4 + this.bobOffset, this.width, 4);

                // Expressions (Eyes)
                ctx.fillStyle = '#fff';
                const eyeY = this.y + this.height / 3 + this.bobOffset;

                // Normal Eyes
                let leftEyeX = this.x + 10 + this.eyeOffset.x;
                let rightEyeX = this.x + this.width - 14 + this.eyeOffset.x;
                let eyeH = 8;

                if (this.blinkTimer > 0) {
                    eyeH = 2; // Blinking
                }

                // Draw Eyes
                if (this.state !== 'REACHED_GOAL') {
                    ctx.fillRect(leftEyeX, eyeY, 4, eyeH);
                    ctx.fillRect(rightEyeX, eyeY, 4, eyeH);
                } else {
                    // Happy eyes ^ ^
                    ctx.beginPath();
                    ctx.moveTo(leftEyeX - 2, eyeY + 4);
                    ctx.lineTo(leftEyeX + 2, eyeY);
                    ctx.lineTo(leftEyeX + 6, eyeY + 4);

                    ctx.moveTo(rightEyeX - 2, eyeY + 4);
                    ctx.lineTo(rightEyeX + 2, eyeY);
                    ctx.lineTo(rightEyeX + 6, eyeY + 4);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Status Indicator (Bubble)
                if (this.expression) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.expression, this.x + this.width / 2, this.y - 12 + this.bobOffset);
                }
            }

            update(dt, obstacles, blockages, gaps, switches) {
                // Update animation state
                // 不晃动，走直线
                // this.bobOffset = Math.sin(Date.now() / 150) * 2;
                if (Math.random() < 0.01) this.blinkTimer = 10;
                if (this.blinkTimer > 0) this.blinkTimer--;

                // Logic State Machine
                switch (this.state) {
                    case 'WALKING':
                        // Check collision with Blockages specifically to trigger "BLOCKED" state
                        // Note: updateWalking handles physics stop.
                        // If updateWalking returns true, it means we hit something.
                        if (this.updateWalking(dt, obstacles, blockages, gaps, switches)) {
                            this.state = 'BLOCKED';
                            this.stateTimer = 0;
                            this.expression = '!';
                        }
                        break;

                    case 'BLOCKED':
                        // 1. Bounce -> Stop
                        // 2. Expression '?'
                        this.stateTimer += dt;
                        this.expression = '?';
                        if (this.stateTimer > 0.5) {
                            this.state = 'TRY_PUSH';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'STOPPED':
                        // If stopped for too long, maybe we should think?
                        this.stateTimer += dt;
                        this.expression = '?';
                        if (this.stateTimer > 1.0) {
                            // Only switch to thinking if we have somewhere else to go or stuck
                            // Actually, if we are just stopped by a wall but checkEnvironment says we can reach goal (false positive?), we must retry?
                            // Let's just go to Thinking
                            this.state = 'THINKING';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'TRY_PUSH':
                        // 3. Expression '>' (Trying to move forward)
                        this.expression = '>';
                        this.stateTimer += dt;

                        // 不移动位置，只做视觉效果（bobOffset 已禁用）
                        // 避免把自己推进障碍物里

                        if (this.stateTimer > 0.8) {
                            this.state = 'THINKING';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'THINKING':
                        this.stateTimer += dt;
                        this.expression = '...';

                        // 每次思考后都重新检查环境并尝试走
                        this.checkEnvironment(obstacles, blockages, gaps, switches);
                        // 总是进入 HESITATE 状态，然后重新尝试走
                        this.state = 'HESITATE';
                        this.stateTimer = 0;
                        this.expression = '!';
                        break;

                    case 'HESITATE':
                        this.stateTimer += dt;
                        this.expression = '!';
                        if (this.stateTimer > 0.5) {
                            this.state = 'ASSESS'; // Quickly assess
                            this.stateTimer = 0;
                        }
                        break;

                    case 'ASSESS':
                        this.stateTimer += dt;
                        this.expression = '...';
                        if (this.stateTimer > 0.5) {
                            this.state = 'WALKING';
                            // Ensure path is planned
                            this.pathQueue = [];
                        }
                        break;

                    case 'REACHED_GOAL':
                        this.expression = '♥';
                        break;
                }

                // Always try to plan path if walking
                if (this.state === 'WALKING') {
                    this.planPath(obstacles, blockages, gaps);
                }
            }

            checkEnvironment(obstacles, blockages, gaps, switches) {
                // 简化版：直接检查是否能到达终点，BFS 会自动找路

                // PRIORITY 1: Can I reach the FINAL GOAL?
                if (this.canReachGoal(this.finalGoalX, this.finalGoalY, obstacles, blockages, gaps)) {
                    // 终点可达！重置卡住标记
                    this.stuckAtClosest = false;
                    if (this.currentGoalX !== this.finalGoalX || this.currentGoalY !== this.finalGoalY) {
                        this.currentGoalX = this.finalGoalX;
                        this.currentGoalY = this.finalGoalY;
                        this.goalX = this.finalGoalX;
                        this.goalY = this.finalGoalY;
                        this.pathQueue = [];
                        return true;
                    }
                    return true;
                }

                // PRIORITY 2: SWITCHES - 如果有 switch 且终点不可达，去找 switch
                if (switches && switches.length > 0) {
                    const keySwitch = switches.find(s => !s.active);
                    if (keySwitch && this.canReachGoal(keySwitch.x, keySwitch.y, obstacles, blockages, gaps)) {
                        this.stuckAtClosest = false; // 重置标记
                        if (this.currentGoalX !== keySwitch.x || this.currentGoalY !== keySwitch.y) {
                            this.currentGoalX = keySwitch.x;
                            this.currentGoalY = keySwitch.y;
                            this.goalX = this.currentGoalX;
                            this.goalY = this.currentGoalY;
                            this.pathQueue = [];
                            return true;
                        }
                        return true;
                    }
                }

                // 每次思考后都重置卡住标记，这样女孩可以重新尝试走
                // 如果还是被卡住，planPath 会重新设置这个标记
                this.stuckAtClosest = false;

                // 即使终点不可达，也让女孩继续往终点方向走
                this.currentGoalX = this.finalGoalX;
                this.currentGoalY = this.finalGoalY;
                this.goalX = this.finalGoalX;
                this.goalY = this.finalGoalY;
                return true;
            }

            // 使用 BFS 检查是否可达
            canReachGoal(targetX, targetY, obstacles, blockages, gaps, ignoreEntities = []) {
                const start = pixelToGrid(this.x, this.y);
                const end = pixelToGrid(targetX, targetY);

                // 如果起点终点相同，可达
                if (start.col === end.col && start.row === end.row) return true;

                // 使用 BFS 检查是否有路径
                const queue = [{ col: start.col, row: start.row }];
                const visited = new Set();
                visited.add(`${start.col},${start.row}`);

                const directions = [
                    { dc: 0, dr: -1 }, { dc: 0, dr: 1 },
                    { dc: -1, dr: 0 }, { dc: 1, dr: 0 }
                ];

                while (queue.length > 0) {
                    const current = queue.shift();

                    for (let dir of directions) {
                        const newCol = current.col + dir.dc;
                        const newRow = current.row + dir.dr;
                        const key = `${newCol},${newRow}`;

                        if (visited.has(key)) continue;
                        if (!isGridCellWalkable(newCol, newRow, obstacles, blockages, gaps, ignoreEntities)) continue;

                        if (newCol === end.col && newRow === end.row) return true;

                        visited.add(key);
                        queue.push({ col: newCol, row: newRow });
                    }
                }
                return false;
            }

            planPath(obstacles, blockages, gaps) {
                // If queue has items, continue consuming
                if (this.pathQueue.length > 0) return;

                // If close to goal, done
                if (Math.abs(this.x - this.goalX) < 5 && Math.abs(this.y - this.goalY) < 5) {
                    this.state = 'REACHED_GOAL';
                    return;
                }

                // 尝试生成完整路径
                const path = findGridPath(this.x, this.y, this.goalX, this.goalY, obstacles, blockages, gaps);

                if (path.length > 0) {
                    this.pathQueue = path;
                } else {
                    // 没有完整路径，触发 BLOCKED
                    if (this.state === 'WALKING') {
                        this.state = 'BLOCKED';
                        this.stateTimer = 0;
                        this.expression = '!';
                    }
                }
            }

            generatePath(tx, ty, obstacles, blockages, gaps) {
                // 使用 BFS 自动找最短路径
                this.pathQueue = findGridPath(this.x, this.y, tx, ty, obstacles, blockages, gaps);
            }

            checkCollisionLine(x1, y1, x2, y2, obstacles, blockages, gaps, ignoreEntities = []) {
                // Check if any point along line collides?
                let minX = Math.min(x1, x2);
                let maxX = Math.max(x1, x2) + this.width;
                let minY = Math.min(y1, y2);
                let maxY = Math.max(y1, y2) + this.height;

                for (let o of obstacles) {
                    if (ignoreEntities.includes(o)) continue;
                    if (maxX > o.x && minX < o.x + o.width && maxY > o.y && minY < o.y + o.height) return true;
                }
                for (let b of blockages) {
                    if (ignoreEntities.includes(b)) continue;
                    if (b.blocked) {
                        if (maxX > b.x && minX < b.x + b.width && maxY > b.y && minY < b.y + b.height) return true;
                    }
                }
                // Check Gaps (must be filled)
                for (let g of gaps) {
                    if (!g.isFilled) {
                        if (maxX > g.x && minX < g.x + g.width && maxY > g.y && minY < g.y + g.height) return true;
                    }
                }
                return false;
            }

            updateWalking(dt, obstacles, blockages, gaps, switches) {
                if (this.pathQueue.length === 0) return;

                const target = this.pathQueue[0];
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 5) {
                    // Reached waypoint - 精确对齐到格子中心
                    this.pathQueue.shift();
                    this.x = target.x;
                    this.y = target.y;

                    // 路径走完了，让状态机在下一帧处理
                    // 不要在这里直接生成新路径，避免来回晃
                    if (this.pathQueue.length === 0) {
                        this.checkEnvironment(obstacles, blockages, gaps, switches);
                        // 不调用 generatePath，让 planPath 在下一帧处理
                    }
                    return;
                }

                // 移动 - 每次只走一个方向，确保走直线
                let moveX = 0, moveY = 0;
                if (Math.abs(dx) > 2) {
                    moveX = Math.sign(dx) * this.speed * dt;
                } else if (Math.abs(dy) > 2) {
                    moveY = Math.sign(dy) * this.speed * dt;
                }

                const newX = this.x + moveX;
                const newY = this.y + moveY;

                // Collision Check
                if (this.checkCollision(newX, newY, obstacles, gaps, blockages)) {
                    // 碰撞了，停止并触发状态机
                    this.state = 'STOPPED';
                    return true;
                }

                this.x = newX;
                this.y = newY;
                return false;
            }

            checkCollision(x, y, obstacles, gaps, blockages) {
                // Obstacles
                for (let obs of obstacles) {
                    if (x < obs.x + obs.width &&
                        x + this.width > obs.x &&
                        y < obs.y + obs.height &&
                        y + this.height > obs.y) {
                        return true;
                    }
                }

                // Blockages (if blocked) - Added this!
                if (blockages) {
                    for (let b of blockages) {
                        if (b.blocked) {
                            if (x < b.x + b.width &&
                                x + this.width > b.x &&
                                y < b.y + b.height &&
                                y + this.height > b.y) {
                                return true;
                            }
                        }
                    }
                }

                // Gaps logic (only if not filled)
                for (let gap of gaps) {
                    if (!gap.isFilled &&
                        x < gap.x + gap.width &&
                        x + this.width > gap.x &&
                        y < gap.y + gap.height &&
                        y + this.height > gap.y) {

                        // Check strict overlap (center point?)
                        // If center of girl is inside gap
                        const cx = x + this.width / 2;
                        const cy = y + this.height / 2;
                        if (cx > gap.x && cx < gap.x + gap.width &&
                            cy > gap.y && cy < gap.y + gap.height) {
                            return true; // Fall in gap
                        }
                    }
                }
                return false;
            }



        }

        // Obstacle (Wall/Block)
        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            draw(ctx) {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.x + 4, this.y + 4, this.width, this.height);

                // Body
                ctx.fillStyle = THEME.obstacle;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Top Highlight
                ctx.fillStyle = THEME.obstacleHighlight;
                ctx.fillRect(this.x, this.y, this.width, 4);
            }
        }

        // Gap (Hole)
        class Gap {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isFilled = false;
            }

            checkFilled(movables) {
                for (let obj of movables) {
                    if (obj.x < this.x + this.width &&
                        obj.x + obj.width > this.x &&
                        obj.y < this.y + this.height &&
                        obj.y + obj.height > this.y) {

                        const overlapWidth = Math.min(obj.x + obj.width, this.x + this.width) - Math.max(obj.x, this.x);
                        const overlapHeight = Math.min(obj.y + obj.height, this.y + this.height) - Math.max(obj.y, this.y);
                        const overlapArea = overlapWidth * overlapHeight;
                        const gapArea = this.width * this.height;
                        const coverageRatio = overlapArea / gapArea;

                        this.coverageRatio = coverageRatio;

                        if (coverageRatio > 0.5) {
                            this.isFilled = true;
                            // 锁定木板在 Gap 位置，变成桥
                            if (!obj.isLocked) {
                                obj.isLocked = true;
                                obj.x = this.x;
                                obj.y = this.y;
                                obj.vx = 0;
                                obj.vy = 0;
                            }
                            this.filledBy = obj; // 记录是哪个木板填的
                            return;
                        }
                    }
                }
                this.isFilled = false;
                this.coverageRatio = 0;
                this.filledBy = null;
            }

            draw(ctx) {
                if (!this.isFilled) {
                    // Inner shadow effect
                    ctx.fillStyle = THEME.gap;
                    ctx.fillRect(this.x, this.y, this.width, this.height);

                    // Inner borders to give depth
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(this.x, this.y, this.width, 10); // Top inner shadow
                    ctx.fillRect(this.x, this.y, 10, this.height); // Left inner shadow
                }
            }
        }

        // Movable Object (Plank/Block) - Redesign: Sleek Slider
        class Movable {
            constructor(x, y, width, height, type = 'plank') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.90;
                this.mass = 2;
            }

            applyForce(fx, fy) {
                this.vx += fx / this.mass;
                this.vy += fy / this.mass;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vx *= this.friction;
                this.vy *= this.friction;

                if (Math.abs(this.vx) < 1) this.vx = 0;
                if (Math.abs(this.vy) < 1) this.vy = 0;

                // Limits
                if (this.x < 0) { this.x = 0; this.vx = 0; }
                if (this.x + this.width > GAME_WIDTH) { this.x = GAME_WIDTH - this.width; this.vx = 0; }
                if (this.y < 0) { this.y = 0; this.vy = 0; }
                if (this.y + this.height > GAME_HEIGHT) { this.y = GAME_HEIGHT - this.height; this.vy = 0; }
            }

            draw(ctx) {
                if (this.type === 'plank') {
                    // Sleek Industrial Design

                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    roundRect(ctx, this.x + 4, this.y + 4, this.width, this.height, 4);
                    ctx.fill();

                    // Main Body: Dark Grey
                    ctx.fillStyle = '#333';
                    roundRect(ctx, this.x, this.y, this.width, this.height, 4);
                    ctx.fill();

                    // Accent: Neon Cyan Edge
                    const lineWidth = 4;
                    ctx.fillStyle = '#0ff'; // Neon

                    // Draw accent strip on left
                    ctx.fillRect(this.x + 10, this.y + 10, 5, this.height - 20);

                    // Draw accent strip on right
                    ctx.fillRect(this.x + this.width - 15, this.y + 10, 5, this.height - 20);

                    // Center detail (Grip lines)
                    ctx.fillStyle = '#444';
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 20, 30, 4);
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 30, 30, 4);
                    ctx.fillRect(this.x + this.width / 2 - 15, this.y + 40, 30, 4);
                }
            }
        }

        // Blockage - Redesign: Geometric Cluster (Shatter Effect)
        class Blockage {
            constructor(x, y, width, height, revealsPath = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.blocked = true;
                this.revealsPath = revealsPath;
                this.opacity = 1.0;

                // Parts for shattered visual
                this.parts = [];
                const cols = 3;
                const rows = 3;
                const partW = width / cols;
                const partH = height / rows;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        this.parts.push({
                            ox: c * partW, // Offset X
                            oy: r * partH, // Offset Y
                            w: partW - 2,  // Gap
                            h: partH - 2,
                            vx: 0,
                            vy: 0,
                            active: true
                        });
                    }
                }
            }

            draw(ctx) {
                if (this.blocked) {
                    // Draw clustered parts
                    ctx.fillStyle = '#C2B280'; // Sand/Stone color
                    // Or maybe a bit more geometric "glitch" color
                    ctx.fillStyle = '#aaa';

                    for (let p of this.parts) {
                        ctx.fillStyle = '#555';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);

                        // Highlight
                        ctx.fillStyle = '#777';
                        ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, 4);
                    }

                } else {
                    // Shatter animation
                    if (this.opacity > 0) {
                        this.opacity -= 0.02;

                        for (let p of this.parts) {
                            if (!p.vx) {
                                // Explode outwards
                                p.vx = (Math.random() - 0.5) * 10;
                                p.vy = (Math.random() - 0.5) * 10;
                            }
                            p.ox += p.vx;
                            p.oy += p.vy;

                            ctx.fillStyle = `rgba(150, 150, 150, ${this.opacity})`;
                            ctx.fillRect(this.x + p.ox, this.y + p.oy, p.w, p.h);
                        }
                    }

                    // Reveal path visual
                    if (this.revealsPath) {
                        const wp = this.revealsPath.waypoint;
                        // Draw Waypoint marker
                        ctx.fillStyle = THEME.exit;
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(wp.x, wp.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }

        // Wind System
        class Wind {
            constructor() {
                this.x = GAME_WIDTH / 2;
                this.y = 50;
                this.active = false;
                this.direction = { x: 0, y: 1 };
                this.strength = 150; // Reduced from 300 to 150
                this.size = 30;
                this.timer = 0;
                this.streams = []; // For visual effect
            }

            setPosition(x, y) {
                this.x = x;
                this.y = y;
            }

            setDirection(key) {
                switch (key) {
                    case 'w': case 'W': this.direction = { x: 0, y: -1 }; break;
                    case 's': case 'S': this.direction = { x: 0, y: 1 }; break;
                    case 'a': case 'A': this.direction = { x: -1, y: 0 }; break;
                    case 'd': case 'D': this.direction = { x: 1, y: 0 }; break;
                }
            }

            activate() {
                this.active = true;
            }

            stop() {
                this.active = false;
            }

            checkBlockages(blockages) {
                if (!this.active) return false;
                const windReach = 200;

                for (let blockage of blockages) {
                    if (!blockage.blocked) continue;

                    const toBlockageX = blockage.x + blockage.width / 2 - this.x;
                    const toBlockageY = blockage.y + blockage.height / 2 - this.y;
                    const distance = Math.sqrt(toBlockageX * toBlockageX + toBlockageY * toBlockageY);

                    if (distance < windReach) {
                        const dot = (toBlockageX * this.direction.x + toBlockageY * this.direction.y) / distance;
                        if (dot > 0.6) {
                            blockage.blocked = false;

                            // Explosion effect
                            particles.spawn(blockage.x + blockage.width / 2, blockage.y + blockage.height / 2, 'dust', 10);
                            return true;
                        }
                    }
                }
                return false;
            }

            pushMovables(movables) {
                if (!this.active) return;
                const windReach = 250;

                for (let obj of movables) {
                    const toObjX = obj.x + obj.width / 2 - this.x;
                    const toObjY = obj.y + obj.height / 2 - this.y;
                    const distance = Math.sqrt(toObjX * toObjX + toObjY * toObjY);

                    if (distance < windReach) {
                        const dot = (toObjX * this.direction.x + toObjY * this.direction.y) / distance;
                        if (dot > 0.5) {
                            const forceMagnitude = this.strength * (1 - distance / windReach);
                            const fx = this.direction.x * forceMagnitude;
                            const fy = this.direction.y * forceMagnitude;
                            obj.applyForce(fx, fy);

                            // Interaction particles
                            if (Math.random() < 0.1) {
                                particles.spawn(obj.x + Math.random() * obj.width, obj.y + Math.random() * obj.height, 'dust', 1);
                            }
                        }
                    }
                }
            }

            checkSwitches(switches) {
                if (!this.active) return;
                for (let s of switches) {
                    const dx = this.x - (s.x + s.width / 2);
                    const dy = this.y - (s.y + s.height / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.size + s.width / 2) {
                        if (!s.active) {
                            s.active = true;
                            // Trigger logic handled in game loop or switch update
                        }
                    }
                }
            }

            draw(ctx) {
                this.timer += 0.1;

                if (this.active) {
                    // Update streams
                    if (Math.random() < 0.3) {
                        this.streams.push({
                            x: this.x + (Math.random() - 0.5) * 40,
                            y: this.y + (Math.random() - 0.5) * 40,
                            len: 0,
                            maxLen: 50 + Math.random() * 100,
                            alpha: 1.0,
                            width: 2 + Math.random() * 3
                        });
                    }
                }

                // Draw streams
                for (let i = this.streams.length - 1; i >= 0; i--) {
                    let s = this.streams[i];
                    s.len += 10;
                    s.alpha -= 0.05;
                    s.x += this.direction.x * 5;
                    s.y += this.direction.y * 5;

                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x + this.direction.x * s.len, s.y + this.direction.y * s.len);
                    ctx.strokeStyle = `rgba(100, 255, 255, ${s.alpha * 0.5})`;
                    ctx.lineWidth = s.width;
                    ctx.stroke();

                    if (s.alpha <= 0) this.streams.splice(i, 1);
                }

                // Cursor visual
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.stroke();

                if (this.active) {
                    // Wind gusts visual (lines)
                    const endX = this.x + this.direction.x * 150;
                    const endY = this.y + this.direction.y * 150;

                    const grad = ctx.createLinearGradient(this.x, this.y, endX, endY);
                    grad.addColorStop(0, 'rgba(100, 255, 255, 0.0)');
                    grad.addColorStop(0.2, 'rgba(100, 255, 255, 0.3)');
                    grad.addColorStop(1, 'rgba(100, 255, 255, 0.0)');

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 40;
                    ctx.lineCap = 'round';
                    // Using a blurred line for "air" feel?
                    // Canvas doesn't support easy blur on stroke without filter
                    // Just accept the gradient for now as a "beam"
                    ctx.stroke();
                }
            }
        }

        // Regenerating Blockage (Grows back)
        class RegeneratingBlockage extends Blockage {
            constructor(x, y, width, height, revealsPath = null) {
                super(x, y, width, height, revealsPath);
                this.regenTime = 5.0; // Seconds to regenerate
                this.regenTimer = 0;
                this.isRegenerating = false;
            }

            update(dt) {
                super.update(dt);
                if (!this.blocked) {
                    this.regenTimer += dt;
                    if (this.regenTimer > this.regenTime) {
                        // Regenerate!
                        this.blocked = true;
                        this.health = 100;
                        this.regenTimer = 0;
                        this.shatterParticles = []; // Reset particles
                    }
                }
            }

            draw(ctx) {
                super.draw(ctx);

                // Draw regeneration indicator (if clearing)
                if (!this.blocked) {
                    const progress = this.regenTimer / this.regenTime;
                    ctx.save();
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.2;
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(this.x + 10, this.y + 10, this.width - 20, this.height - 20);

                    // Progress bar or growing ghost
                    ctx.fillStyle = 'rgba(255, 68, 68, 0.1)';
                    ctx.fillRect(this.x, this.y + this.height * (1 - progress), this.width, this.height * progress);
                    ctx.restore();
                }
            }
        }

        // Wind Switch (Trigger)
        class WindSwitch {
            constructor(x, y, width, height, targetId = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.active = false;
                this.targetId = targetId; // ID of object this switch controls (e.g. a door)
                this.spin = 0;
            }

            update(dt) {
                if (this.active) {
                    this.spin += dt * 10;
                    if (this.spin > Math.PI * 2) this.spin -= Math.PI * 2;
                }
            }

            draw(ctx) {
                // Base
                ctx.fillStyle = '#444';
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Sensor / Fan
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                if (this.active) {
                    ctx.rotate(this.spin);
                    ctx.fillStyle = '#0ff'; // Bright Cyan
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#0ff';
                } else {
                    ctx.fillStyle = '#555'; // Inactive
                    // Slow idle spin
                    ctx.rotate(Date.now() / 1000);
                }

                // Draw simple fan blades
                ctx.fillRect(-15, -4, 30, 8);
                ctx.fillRect(-4, -15, 8, 30);

                // Center hub
                ctx.fillStyle = this.active ? '#fff' : '#888';
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Border
                ctx.strokeStyle = this.active ? '#fff' : '#888';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }

        // --- LEVEL SYSTEM ---
        const LEVELS = [
            // Level 1: User Design (Simple Exit Block)
            {
                id: 1,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [],
                blockages: [
                    { col: 3, row: 1, type: 'static' }
                ],
                movables: [],
                gaps: [],
                switches: []
            },

            // Level 2: User Design (Tunnel/Maze)
            {
                id: 2,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [
                    { col: 1, row: 0 },
                    { col: 2, row: 1 },
                    { col: 2, row: 3 }
                ],
                blockages: [
                    // The central block reveals the detour waypoint
                    {
                        col: 2, row: 2, type: 'static', id: 1,
                        revealsPath: { waypoint: { col: 2, row: 2 } } // Go to (2,2) (The cleared path)
                    }
                ],
                movables: [],
                gaps: [],
                switches: []
            },

            // Level 3: User Design (Trapped Start)
            {
                id: 3,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [
                    { col: 1, row: 1 },
                    { col: 0, row: 2 }
                ],
                blockages: [
                    { col: 0, row: 0, type: 'static', id: 1, revealsPath: { waypoint: { col: 1, row: 0 } } },
                    { col: 3, row: 0, type: 'static', id: 2 },
                    { col: 2, row: 1, type: 'static', id: 3 },
                    { col: 3, row: 2, type: 'static', id: 4 }
                ],
                gaps: [],
                movables: [],
                switches: []
            },

            // Level 4: The Switch (Original Demo)
            {
                id: 4,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [],
                blockages: [
                    { col: 2, row: 1, type: 'static', id: 1 }
                ],
                gaps: [],
                movables: [],
                switches: [
                    { col: 2, row: 2, targetId: 1 }
                ]
            },

            // Level 5: Simple Gap
            {
                id: 5,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [
                    { col: 3, row: 0 },
                    { col: 1, row: 2 },
                    { col: 0, row: 3 }
                ],
                blockages: [],
                gaps: [
                    { col: 2, row: 1 }
                ],
                movables: [],
                switches: []
            },

            // Level 6: Gap + Plank + Blockage
            {
                id: 6,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [
                    { col: 1, row: 1 }
                ],
                blockages: [
                    { col: 1, row: 2, type: 'static', id: 1 }
                ],
                gaps: [
                    { col: 2, row: 1 },
                    { col: 3, row: 2 }
                ],
                movables: [
                    { col: 1, row: 0, type: 'plank' },
                    { col: 1, row: 3, type: 'plank' }
                ],
                switches: []
            },

            // Level 7: Multiple Gaps + Blockages
            {
                id: 7,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [
                    { col: 2, row: 1 }
                ],
                blockages: [
                    { col: 3, row: 0, type: 'static', id: 1 },
                    { col: 2, row: 3, type: 'static', id: 2 }
                ],
                gaps: [
                    { col: 1, row: 1 },
                    { col: 2, row: 2 }
                ],
                movables: [],
                switches: []
            },

            // Level 8: Regenerating Blockages
            {
                id: 8,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [],
                blockages: [
                    { col: 0, row: 0, type: 'regen' },
                    { col: 1, row: 1, type: 'regen' },
                    { col: 2, row: 1, type: 'regen' },
                    { col: 3, row: 2, type: 'regen' },
                    { col: 3, row: 3, type: 'regen' }
                ],
                gaps: [],
                movables: [],
                switches: []
            },

            // Level 9: Regen + Gaps Maze
            {
                id: 9,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [],
                blockages: [
                    { col: 2, row: 0, type: 'static', id: 1 },
                    { col: 3, row: 0, type: 'regen' },
                    { col: 2, row: 1, type: 'regen' },
                    { col: 2, row: 2, type: 'regen' },
                    { col: 3, row: 2, type: 'regen' },
                    { col: 2, row: 3, type: 'regen' },
                    { col: 3, row: 3, type: 'regen' }
                ],
                gaps: [
                    { col: 1, row: 1 },
                    { col: 1, row: 2 },
                    { col: 1, row: 3 }
                ],
                movables: [],
                switches: []
            },

            // Level 10: Many Gaps + Plank
            {
                id: 10,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [],
                blockages: [],
                gaps: [
                    { col: 2, row: 0 },
                    { col: 1, row: 1 },
                    { col: 2, row: 1 },
                    { col: 2, row: 2 },
                    { col: 3, row: 3 }
                ],
                movables: [
                    { col: 0, row: 3, type: 'plank' }
                ],
                switches: []
            },

            // Level 11: Obstacle + Gaps + Plank
            {
                id: 11,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [
                    { col: 1, row: 1 }
                ],
                blockages: [],
                gaps: [
                    { col: 1, row: 2 },
                    { col: 1, row: 3 }
                ],
                movables: [
                    { col: 0, row: 0, type: 'plank' }
                ],
                switches: []
            },

            // Level 12: Diagonal Gaps
            {
                id: 12,
                gridStart: { col: 0, row: 1 },
                gridExit: { col: 3, row: 1 },
                obstacles: [],
                blockages: [],
                gaps: [
                    { col: 1, row: 0 },
                    { col: 2, row: 1 },
                    { col: 3, row: 2 }
                ],
                movables: [
                    { col: 3, row: 3, type: 'plank' }
                ],
                switches: []
            }
        ];

        // 游戏状态
        let currentLevelIndex = 0; // 0-based index for LEVELS array
        let girl = null;
        let obstacles = [];
        let blockages = [];
        let gaps = [];
        let movables = [];
        let switches = []; // New
        let wind = new Wind();

        // Helper to get grid position
        function getGridPos(col, row) {
            return {
                x: GRID_OFFSET_X + col * CELL_SIZE,
                y: GRID_OFFSET_Y + row * CELL_SIZE
            };
        }

        // Helper to parse grid config
        function parseGrid(config) {
            if (!config) return null;
            return getGridPos(config.col, config.row);
        }

        function loadLevel(levelId) {
            const levelData = LEVELS.find(l => l.id === levelId);
            if (!levelData) return;

            currentLevel = levelId;
            levelIndicator.innerText = "LEVEL " + levelId;

            obstacles = [];
            blockages = [];
            gaps = [];
            movables = [];
            switches = [];

            // Setup obstacles
            if (levelData.obstacles) {
                levelData.obstacles.forEach(obs => {
                    const pos = getGridPos(obs.col, obs.row);
                    obstacles.push(new Obstacle(pos.x, pos.y, CELL_SIZE, CELL_SIZE));
                });
            }

            // Setup blockages
            if (levelData.blockages) {
                levelData.blockages.forEach(blk => {
                    const pos = getGridPos(blk.col, blk.row);
                    let reveals = null;
                    if (blk.revealsPath) {
                        // Calculate waypoint center
                        const wp = getGridPos(blk.revealsPath.waypoint.col, blk.revealsPath.waypoint.row);
                        reveals = { waypoint: { x: wp.x + CELL_SIZE / 2, y: wp.y + CELL_SIZE / 2 } };
                    }

                    if (blk.type === 'regen') {
                        blockages.push(new RegeneratingBlockage(pos.x, pos.y, CELL_SIZE, CELL_SIZE, reveals));
                    } else {
                        const b = new Blockage(pos.x, pos.y, CELL_SIZE, CELL_SIZE, reveals);
                        if (blk.id) b.id = blk.id; // Assign ID for switches
                        blockages.push(b);
                    }
                });
            }

            // Setup gaps
            if (levelData.gaps) {
                levelData.gaps.forEach(gap => {
                    const pos = getGridPos(gap.col, gap.row);
                    gaps.push(new Gap(pos.x, pos.y, CELL_SIZE, CELL_SIZE));
                });
            }

            // Setup movables
            if (levelData.movables) {
                levelData.movables.forEach(mov => {
                    const pos = getGridPos(mov.col, mov.row);
                    let w = CELL_SIZE;
                    let h = CELL_SIZE;
                    movables.push(new Movable(pos.x, pos.y, w, h, mov.type));
                });
            }

            // Setup switches
            if (levelData.switches) {
                levelData.switches.forEach(sw => {
                    const pos = getGridPos(sw.col, sw.row);
                    switches.push(new WindSwitch(pos.x, pos.y, CELL_SIZE, CELL_SIZE, sw.targetId));
                });
            }

            // Setup Girl
            const startPos = getGridPos(levelData.gridStart.col, levelData.gridStart.row);
            const goalPos = getGridPos(levelData.gridExit.col, levelData.gridExit.row);

            girl = new Girl(startPos.x + (CELL_SIZE - GIRL_SIZE) / 2, startPos.y + (CELL_SIZE - GIRL_SIZE) / 2, goalPos);
        }

        // --- LEVEL EDITOR ---
        class LevelEditor {
            constructor() {
                this.active = false;
                this.grid = Array(GRID_H).fill(null).map(() => Array(GRID_W).fill(0));
                this.startPos = { col: 0, row: 1 };
                this.exitPos = { col: 3, row: 1 };

                // 0: Empty, 1: Obstacle, 2: Block(Static), 3: Block(Regen)
                // 4: Gap, 5: Plank, 6: Switch
                this.selectedType = 1;
                this.typeNames = ["Clear", "Obstacle", "Block(Static)", "Block(Regen)", "Gap", "Plank", "Switch", "Start", "Exit"];
            }

            toggle() {
                this.active = !this.active;
                if (this.active) {
                    // Try to populate grid from current level? 
                    // For simplicity, start clean or keep editor state.
                    // (Advanced: Parse current objects back to grid)
                }
            }

            handleClick(x, y) {
                if (!this.active) return;

                // Convert screen to grid
                let col = Math.floor((x - GRID_OFFSET_X) / CELL_SIZE);
                let row = Math.floor((y - GRID_OFFSET_Y) / CELL_SIZE);

                if (col >= 0 && col < GRID_W && row >= 0 && row < GRID_H) {
                    if (this.selectedType === 7) {
                        this.startPos = { col, row };
                    } else if (this.selectedType === 8) {
                        this.exitPos = { col, row };
                    } else {
                        // Toggle or set?
                        this.grid[row][col] = this.selectedType;
                    }
                }
            }

            draw(ctx) {
                if (!this.active) return;

                // Dark overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

                // Draw Grid
                ctx.save();
                ctx.translate(GRID_OFFSET_X, GRID_OFFSET_Y);

                for (let r = 0; r < GRID_H; r++) {
                    for (let c = 0; c < GRID_W; c++) {
                        const val = this.grid[r][c];
                        const x = c * CELL_SIZE;
                        const y = r * CELL_SIZE;

                        // Border
                        ctx.strokeStyle = '#555';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);

                        // Content
                        if (r === this.startPos.row && c === this.startPos.col) {
                            ctx.fillStyle = '#f0f'; ctx.fillText("START", x + 10, y + 40);
                        }
                        if (r === this.exitPos.row && c === this.exitPos.col) {
                            ctx.fillStyle = '#ff0'; ctx.fillText("EXIT", x + 15, y + 40);
                        }

                        if (val === 1) { ctx.fillStyle = '#888'; ctx.fillRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10); }
                        if (val === 2) { ctx.fillStyle = '#f88'; ctx.fillRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10); ctx.fillStyle = '#000'; ctx.fillText("BLK", x + 10, y + 20); }
                        if (val === 3) { ctx.fillStyle = '#f44'; ctx.fillRect(x + 5, y + 5, CELL_SIZE - 10, CELL_SIZE - 10); ctx.fillStyle = '#000'; ctx.fillText("REG", x + 10, y + 20); }
                        if (val === 4) { ctx.fillStyle = '#000'; ctx.fillRect(x + 10, y + 10, CELL_SIZE - 20, CELL_SIZE - 20); } // Gap
                        if (val === 5) { ctx.fillStyle = '#44f'; ctx.fillRect(x + 15, y + 50, CELL_SIZE - 30, 20); } // Plank
                        if (val === 6) { ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, 10, 0, Math.PI * 2); ctx.fill(); } // Switch
                    }
                }
                ctx.restore();

                // HUD
                ctx.fillStyle = '#fff';
                ctx.font = '16px Monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`EDITOR MODE [E] to Close`, 20, 30);
                ctx.fillText(`Selected: [${this.selectedType}] ${this.typeNames[this.selectedType]}`, 20, 50);
                ctx.fillText(`Keys: 0-Clear, 1-Obs, 2-Stat, 3-Regen, 4-Gap, 5-Plank, 6-Switch, 7-Start, 8-Exit`, 20, 70);
                ctx.fillText(`[P] Print Config`, 20, 90);
            }

            exportConfig() {
                // Generate JSON
                let config = {
                    id: LEVELS.length + 1,
                    gridStart: this.startPos,
                    gridExit: this.exitPos,
                    obstacles: [],
                    blockages: [],
                    gaps: [],
                    movables: [],
                    switches: []
                };

                let switchCount = 0;
                let blockCount = 0;

                for (let r = 0; r < GRID_H; r++) {
                    for (let c = 0; c < GRID_W; c++) {
                        const val = this.grid[r][c];
                        if (val === 1) config.obstacles.push({ col: c, row: r });
                        if (val === 2) {
                            blockCount++;
                            config.blockages.push({ col: c, row: r, type: 'static', id: blockCount });
                        }
                        if (val === 3) config.blockages.push({ col: c, row: r, type: 'regen' });
                        if (val === 4) config.gaps.push({ col: c, row: r });
                        if (val === 5) config.movables.push({ col: c, row: r, type: 'plank' });
                        if (val === 6) {
                            config.switches.push({ col: c, row: r, targetId: 1 }); // Default link to ID 1
                        }
                    }
                }

                const json = JSON.stringify(config, null, 2);
                console.log(json);
                window.alert("Config copied to clipboard (hypothetically) / Check Console!\n" + JSON.stringify(config));
                // Try copy
                try { navigator.clipboard.writeText(json); } catch (e) { }
            }
        }

        const editor = new LevelEditor();

        // Input Handling

        // Track active wind keys
        const activeKeys = new Set();

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            // Level Controls
            if (key === 'r') {
                loadLevel(currentLevel);
                return;
            }
            if (key === 'e') {
                editor.toggle();
                return;
            }
            if (editor.active) {
                if (key === 'p') editor.exportConfig();
                if (key >= '0' && key <= '8') editor.selectedType = parseInt(key);
                return;
            }

            if (key >= '1' && key <= '9') {
                const id = parseInt(key);
                if (LEVELS.find(l => l.id === id)) loadLevel(id);
                return;
            }
            // N = Next level, P = Previous level
            if (key === 'n') {
                const nextLevel = currentLevel + 1;
                if (LEVELS.find(l => l.id === nextLevel)) loadLevel(nextLevel);
                return;
            }
            if (key === 'p' && !editor.active) {
                const prevLevel = currentLevel - 1;
                if (LEVELS.find(l => l.id === prevLevel)) loadLevel(prevLevel);
                return;
            }

            // Wind Controls (WASD)
            if (['w', 'a', 's', 'd'].includes(key)) {
                if (!activeKeys.has(key)) {
                    activeKeys.add(key);
                    wind.setDirection(key);
                    wind.activate();
                    wind.checkBlockages(blockages);
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();

            if (['w', 'a', 's', 'd'].includes(key)) {
                activeKeys.delete(key);
                if (activeKeys.size === 0) {
                    wind.stop();
                } else {
                    // Update direction to remaining key (optional, simplistic)
                    const lastKey = Array.from(activeKeys).pop();
                    wind.setDirection(lastKey);
                }
            }
        });

        // Mouse Move & Click
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let mouseX = (e.clientX - rect.left) * scaleX;
            let mouseY = (e.clientY - rect.top) * scaleY;
            wind.setPosition(mouseX, mouseY);
        });

        canvas.addEventListener('mousedown', (e) => {
            if (editor.active) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                let mouseX = (e.clientX - rect.left) * scaleX;
                let mouseY = (e.clientY - rect.top) * scaleY;
                editor.handleClick(mouseX, mouseY);
            }
        });

        // Initialize
        loadLevel(1);
        requestAnimationFrame(gameLoop);

        // 游戏循环
        let lastTime = Date.now();

        function gameLoop() {
            const now = Date.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            // Updates
            for (let obj of movables) obj.update(dt);
            for (let s of switches) {
                s.update(dt);
                // Link logic
                if (s.active && s.targetId) {
                    const target = blockages.find(b => b.id === s.targetId);
                    if (target) target.blocked = false; // Open!
                }
            }
            for (let gap of gaps) gap.checkFilled(movables);
            // 只把未锁定的木板当成障碍物（锁定的木板已变成桥）
            const unlockedMovables = movables.filter(m => !m.isLocked);
            if (girl) girl.update(dt, obstacles.concat(unlockedMovables), blockages, gaps, switches);

            if (wind.active) {
                wind.pushMovables(movables);
                wind.checkBlockages(blockages);
                wind.checkSwitches(switches);
            }

            particles.update(dt);

            // Draw
            // 1. Background
            ctx.fillStyle = THEME.bg;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            if (editor.active) {
                editor.draw(ctx);
                requestAnimationFrame(gameLoop);
                return;
            }

            // 2. Draw Grid (Subtle)
            ctx.save();
            ctx.translate(GRID_OFFSET_X, GRID_OFFSET_Y);
            for (let r = 0; r < GRID_H; r++) {
                for (let c = 0; c < GRID_W; c++) {
                    ctx.fillStyle = THEME.grid;
                    ctx.fillRect(c * CELL_SIZE + 1, r * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                }
            }
            ctx.restore();

            // 3. Draw Entities

            // Exit Marker (New) - Use FINAL GOAL
            if (girl) {
                // Determine exit position (goal)
                // Draw a glowing floor plate
                ctx.save();
                // Use finalGoalX/Y instead of goalX/Y which changes
                const exitX = girl.finalGoalX + GIRL_SIZE / 2;
                const exitY = girl.finalGoalY + GIRL_SIZE / 2;
                const exitRadius = 30 + Math.sin(now / 500) * 5;

                // Outer Glow
                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.2)'; // Warm Orange/Yellow
                ctx.fill();

                // Inner Core (Restored)
                ctx.beginPath();
                ctx.arc(exitX, exitY, exitRadius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 170, 51, 0.4)';
                ctx.fill();

                // Light Beam (Restored Gradient)
                const grad = ctx.createLinearGradient(exitX, exitY, exitX, exitY - 150);
                grad.addColorStop(0, 'rgba(255, 170, 51, 0.3)');
                grad.addColorStop(1, 'rgba(255, 170, 51, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(exitX - 20, exitY);
                ctx.lineTo(exitX + 20, exitY);
                ctx.lineTo(exitX + 30, exitY - 150);
                ctx.lineTo(exitX - 30, exitY - 150);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }

            for (let gap of gaps) gap.draw(ctx);
            for (let obs of obstacles) obs.draw(ctx);
            for (let blk of blockages) blk.draw(ctx);
            for (let mov of movables) mov.draw(ctx);
            for (let sw of switches) sw.draw(ctx); // Draw switches

            if (girl) girl.draw(ctx);
            wind.draw(ctx);
            particles.draw(ctx);

            // 6. Lighting / Vignette Overlay
            const gradient = ctx.createRadialGradient(
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 200,
                GAME_WIDTH / 2, GAME_HEIGHT / 2, 500
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            requestAnimationFrame(gameLoop);
        }

        // 启动游戏
        gameLoop();
    </script>
</body>

</html>