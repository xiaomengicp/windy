<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>女孩与风 - 原型v1</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #2a2a2a;
            font-family: sans-serif;
            color: #fff;
        }
        
        #gameCanvas {
            border: 2px solid #444;
            background: #1a1a1a;
        }
        
        .controls {
            margin-top: 20px;
            padding: 15px;
            background: #333;
            border-radius: 8px;
        }
        
        .info {
            margin-top: 10px;
            font-size: 14px;
            color: #aaa;
        }
        
        .debug {
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>
    <h2>女孩与风 - 原型测试</h2>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    
    <div class="controls">
        <div><strong>控制：</strong></div>
        <div>• 鼠标移动 - 移动风源位置（蓝色圆圈）</div>
        <div>• 按住W/A/S/D - 朝对应方向吹风（上/左/下/右）</div>
        <div>• 松开 - 停止吹风</div>
        <div>• R键 - 重置关卡</div>
        <div>• 1/2键 - 切换关卡</div>
        <div class="info">第1关：吹开遮蔽物 | 第2关：吹动木板搭桥</div>
    </div>
    
    <div class="debug" id="debugInfo"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const debugInfo = document.getElementById('debugInfo');
        
        // 游戏常量
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 400;
        const GIRL_SIZE = 20;
        const GIRL_SPEED = 60; // pixels per second
        
        // 女孩类
        class Girl {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = GIRL_SIZE;
                this.height = GIRL_SIZE;
                this.goalX = GAME_WIDTH - 50; // 最终目标是右侧
                this.goalY = GAME_HEIGHT / 2;
                this.currentGoalX = this.goalX; // 当前行走目标
                this.currentGoalY = this.goalY;
                this.state = 'WALKING'; // WALKING, STOPPED, TRY_PUSH, OBSERVE, HESITATE, WALKING_DETOUR
                this.speed = GIRL_SPEED;
                this.color = '#ff6b9d'; // 粉色
                this.stateTimer = 0; // 状态计时器
                this.detourPath = null; // 绕路路径
                this.reachedWaypoint = false; // 是否已到达waypoint
            }
            
            update(dt, obstacles, blockages, gaps = []) {
                this.stateTimer += dt;
                
                switch(this.state) {
                    case 'WALKING':
                        this.updateWalking(dt, obstacles, gaps);
                        break;
                    case 'STOPPED':
                        // 刚停下，等待一小段时间
                        if (this.stateTimer > 0.3) {
                            this.state = 'TRY_PUSH';
                            this.stateTimer = 0;
                        }
                        break;
                    case 'TRY_PUSH':
                        // 尝试推障碍物（动画效果）
                        if (this.stateTimer > 1.0) {
                            this.state = 'OBSERVE';
                            this.stateTimer = 0;
                        }
                        break;
                    case 'OBSERVE':
                        // 观察周围，每隔1.5秒检查一次
                        if (this.stateTimer > 1.5) {
                            // 先检查是否有绕路显露
                            let foundSolution = false;
                            
                            for (let blockage of blockages) {
                                if (!blockage.blocked && blockage.revealsPath) {
                                    // 发现了绕路！
                                    this.detourPath = blockage.revealsPath;
                                    this.state = 'HESITATE';
                                    this.stateTimer = 0;
                                    foundSolution = true;
                                    break;
                                }
                            }
                            
                            // 如果没有绕路，检查是否有缺口被填满（桥搭好了）
                            if (!foundSolution && gaps) {
                                for (let gap of gaps) {
                                    if (gap.isFilled) {
                                        // 桥搭好了！可以直接走
                                        this.state = 'HESITATE';
                                        this.stateTimer = 0;
                                        foundSolution = true;
                                        break;
                                    }
                                }
                            }
                            
                            // 如果还没找到解决方案，重置计时器继续观察
                            if (!foundSolution) {
                                this.stateTimer = 0;
                            }
                        }
                        break;
                    case 'HESITATE':
                        // 犹豫一下（增加到1.5秒让玩家更能感受到她在决定）
                        if (this.stateTimer > 1.5) {
                            // 如果有绕路，走绕路；否则恢复直接走
                            if (this.detourPath) {
                                this.state = 'WALKING_DETOUR';
                            } else {
                                this.state = 'WALKING';
                            }
                            this.stateTimer = 0;
                        }
                        break;
                    case 'WALKING_DETOUR':
                        this.updateWalkingDetour(dt, obstacles);
                        break;
                    case 'REACHED_GOAL':
                        // 成功到达
                        break;
                }
            }
            
            updateWalking(dt, obstacles, gaps) {
                // 朝当前目标移动
                const dx = this.currentGoalX - this.x;
                const dy = this.currentGoalY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    // 归一化方向并移动
                    const moveX = (dx / distance) * this.speed * dt;
                    const moveY = (dy / distance) * this.speed * dt;
                    
                    // 检查碰撞
                    const nextX = this.x + moveX;
                    const nextY = this.y + moveY;
                    
                    if (!this.checkCollision(nextX, nextY, obstacles, gaps)) {
                        this.x = nextX;
                        this.y = nextY;
                    } else {
                        // 碰到障碍物或缺口，停下
                        this.state = 'STOPPED';
                        this.stateTimer = 0;
                    }
                } else {
                    // 到达当前目标
                    if (this.currentGoalX === this.goalX && this.currentGoalY === this.goalY) {
                        this.state = 'REACHED_GOAL';
                    }
                }
            }
            
            updateWalkingDetour(dt, obstacles) {
                if (!this.detourPath) return;
                
                const waypoint = this.detourPath.waypoint;
                
                if (!this.reachedWaypoint) {
                    // 还没到waypoint，走向waypoint
                    const toWaypointX = waypoint.x - this.x;
                    const toWaypointY = waypoint.y - this.y;
                    const distToWaypoint = Math.sqrt(toWaypointX * toWaypointX + toWaypointY * toWaypointY);
                    
                    if (distToWaypoint > 15) {
                        // 继续走向waypoint
                        const moveX = (toWaypointX / distToWaypoint) * this.speed * dt;
                        const moveY = (toWaypointY / distToWaypoint) * this.speed * dt;
                        this.x += moveX;
                        this.y += moveY;
                    } else {
                        // 到达waypoint
                        this.reachedWaypoint = true;
                    }
                } else {
                    // 已到达waypoint，现在走向最终目标
                    const toGoalX = this.goalX - this.x;
                    const toGoalY = this.goalY - this.y;
                    const distToGoal = Math.sqrt(toGoalX * toGoalX + toGoalY * toGoalY);
                    
                    if (distToGoal > 5) {
                        const moveX = (toGoalX / distToGoal) * this.speed * dt;
                        const moveY = (toGoalY / distToGoal) * this.speed * dt;
                        this.x += moveX;
                        this.y += moveY;
                    } else {
                        this.state = 'REACHED_GOAL';
                    }
                }
            }
            
            checkForDetour(blockages) {
                // 检查是否有绕路显露出来
                for (let blockage of blockages) {
                    if (!blockage.blocked && blockage.revealsPath) {
                        // 发现了绕路！
                        this.detourPath = blockage.revealsPath;
                        this.state = 'HESITATE';
                        this.stateTimer = 0;
                        return;
                    }
                }
            }
            
            checkCollision(x, y, obstacles, gaps = []) {
                // 检查障碍物碰撞
                for (let obs of obstacles) {
                    if (x < obs.x + obs.width &&
                        x + this.width > obs.x &&
                        y < obs.y + obs.height &&
                        y + this.height > obs.y) {
                        return true;
                    }
                }
                
                // 检查缺口碰撞（只有未填满的缺口才会阻挡）
                for (let gap of gaps) {
                    if (!gap.isFilled) {
                        if (x < gap.x + gap.width &&
                            x + this.width > gap.x &&
                            y < gap.y + gap.height &&
                            y + this.height > gap.y) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            draw(ctx) {
                // 画女孩（简单圆形）
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2);
                ctx.fill();
                
                // 状态指示
                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                
                if (this.state === 'STOPPED') {
                    ctx.fillText('!', this.x + this.width/2 - 3, this.y - 5);
                } else if (this.state === 'TRY_PUSH') {
                    // 推的动画（小箭头）
                    ctx.fillText('→', this.x + this.width + 5, this.y + this.height/2 + 4);
                } else if (this.state === 'OBSERVE') {
                    // 观察状态，周期性闪烁
                    const pulse = Math.sin(this.stateTimer * Math.PI) > 0.5;
                    if (pulse) {
                        ctx.fillText('?', this.x + this.width/2 - 4, this.y - 5);
                    }
                } else if (this.state === 'HESITATE') {
                    ctx.fillText('...', this.x + this.width/2 - 8, this.y - 5);
                } else if (this.state === 'REACHED_GOAL') {
                    ctx.fillText('✓', this.x + this.width/2 - 4, this.y - 5);
                }
            }
        }
        
        // 障碍物类
        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = '#555';
            }
            
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // 边框
                ctx.strokeStyle = '#777';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }
        
        // 缺口类（女孩不能通过的空隙）
        class Gap {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isFilled = false; // 是否被填上了
            }
            
            checkFilled(movables) {
                // 检查是否有可移动物体覆盖了这个缺口
                for (let obj of movables) {
                    if (obj.x < this.x + this.width &&
                        obj.x + obj.width > this.x &&
                        obj.y < this.y + this.height &&
                        obj.y + obj.height > this.y) {
                        // 有物体覆盖，检查覆盖程度
                        const overlapWidth = Math.min(obj.x + obj.width, this.x + this.width) - Math.max(obj.x, this.x);
                        const overlapHeight = Math.min(obj.y + obj.height, this.y + this.height) - Math.max(obj.y, this.y);
                        const overlapArea = overlapWidth * overlapHeight;
                        const gapArea = this.width * this.height;
                        const coverageRatio = overlapArea / gapArea;
                        
                        // 存储覆盖率用于调试
                        this.coverageRatio = coverageRatio;
                        
                        if (coverageRatio > 0.5) { // 覆盖50%以上就算填满
                            this.isFilled = true;
                            return;
                        }
                    }
                }
                this.isFilled = false;
                this.coverageRatio = 0;
            }
            
            draw(ctx) {
                if (!this.isFilled) {
                    // 画成深色的空隙
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // 边框
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                    ctx.setLineDash([]);
                }
            }
        }
        
        // 可移动物体类（如木板）
        class Movable {
            constructor(x, y, width, height, type = 'plank') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.vx = 0; // x方向速度
                this.vy = 0; // y方向速度
                this.friction = 0.85; // 摩擦力
                this.mass = 1; // 质量（影响被风吹的难度）
            }
            
            applyForce(fx, fy) {
                // 施加力（来自风）
                this.vx += fx / this.mass;
                this.vy += fy / this.mass;
            }
            
            update(dt) {
                // 更新位置
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                // 应用摩擦力
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                // 速度太小就停下
                if (Math.abs(this.vx) < 1) this.vx = 0;
                if (Math.abs(this.vy) < 1) this.vy = 0;
                
                // 边界限制
                if (this.x < 0) { this.x = 0; this.vx = 0; }
                if (this.x + this.width > GAME_WIDTH) { this.x = GAME_WIDTH - this.width; this.vx = 0; }
                if (this.y < 0) { this.y = 0; this.vy = 0; }
                if (this.y + this.height > GAME_HEIGHT) { this.y = GAME_HEIGHT - this.height; this.vy = 0; }
            }
            
            draw(ctx) {
                if (this.type === 'plank') {
                    // 木板
                    ctx.fillStyle = '#8b6f47';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // 木纹
                    ctx.strokeStyle = '#6b5337';
                    ctx.lineWidth = 2;
                    for (let i = 5; i < this.width; i += 15) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + i, this.y);
                        ctx.lineTo(this.x + i, this.y + this.height);
                        ctx.stroke();
                    }
                    
                    // 边框
                    ctx.strokeStyle = '#5a4428';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                }
            }
        }
        
        // 遮蔽物类（可被风吹开，显露绕路）
        class Blockage {
            constructor(x, y, width, height, revealsPath = null) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.blocked = true;
                this.color = '#8b6f47'; // 棕色（树叶/布）
                this.revealsPath = revealsPath; // 显露的绕路路径 {waypoint: {x, y}}
            }
            
            draw(ctx) {
                if (this.blocked) {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // 纹理效果
                    ctx.strokeStyle = '#6b5337';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < this.width; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + i, this.y);
                        ctx.lineTo(this.x + i, this.y + this.height);
                        ctx.stroke();
                    }
                } else {
                    // 被吹开后，显示隐藏的路径
                    if (this.revealsPath) {
                        ctx.strokeStyle = '#4a4';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(this.x, this.y, this.width, this.height);
                        ctx.setLineDash([]);
                        
                        // 标记waypoint
                        const wp = this.revealsPath.waypoint;
                        ctx.fillStyle = 'rgba(68, 170, 68, 0.3)';
                        ctx.beginPath();
                        ctx.arc(wp.x, wp.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        // 风系统
        class Wind {
            constructor() {
                this.x = GAME_WIDTH / 2; // 风源位置
                this.y = 50;
                this.active = false;
                this.direction = { x: 0, y: 1 }; // 默认向下
                this.strength = 200; // 风力
                this.size = 30;
            }
            
            setPosition(x, y) {
                this.x = x;
                this.y = y;
            }
            
            setDirection(key) {
                switch(key) {
                    case 'w':
                    case 'W':
                        this.direction = { x: 0, y: -1 };
                        break;
                    case 's':
                    case 'S':
                        this.direction = { x: 0, y: 1 };
                        break;
                    case 'a':
                    case 'A':
                        this.direction = { x: -1, y: 0 };
                        break;
                    case 'd':
                    case 'D':
                        this.direction = { x: 1, y: 0 };
                        break;
                }
            }
            
            activate() {
                this.active = true;
            }
            
            stop() {
                this.active = false;
            }
            
            checkBlockages(blockages) {
                if (!this.active) return false;
                
                const windReach = 150;
                
                for (let blockage of blockages) {
                    if (!blockage.blocked) continue;
                    
                    // 从风源位置检测
                    const toBlockageX = blockage.x + blockage.width/2 - this.x;
                    const toBlockageY = blockage.y + blockage.height/2 - this.y;
                    const distance = Math.sqrt(toBlockageX * toBlockageX + toBlockageY * toBlockageY);
                    
                    if (distance < windReach) {
                        const dot = (toBlockageX * this.direction.x + toBlockageY * this.direction.y) / distance;
                        
                        if (dot > 0.6) {
                            blockage.blocked = false;
                            return true;
                        }
                    }
                }
                return false;
            }
            
            pushMovables(movables) {
                if (!this.active) return;
                
                const windReach = 150;
                
                for (let obj of movables) {
                    const toObjX = obj.x + obj.width/2 - this.x;
                    const toObjY = obj.y + obj.height/2 - this.y;
                    const distance = Math.sqrt(toObjX * toObjX + toObjY * toObjY);
                    
                    if (distance < windReach) {
                        // 计算风力方向与物体方向的相似度
                        const dot = (toObjX * this.direction.x + toObjY * this.direction.y) / distance;
                        
                        if (dot > 0.5) {
                            // 施加力（距离越近力越大）
                            const forceMagnitude = this.strength * (1 - distance / windReach);
                            const fx = this.direction.x * forceMagnitude;
                            const fy = this.direction.y * forceMagnitude;
                            obj.applyForce(fx, fy);
                        }
                    }
                }
            }
            
            draw(ctx) {
                // 画风源（一个圆圈）
                ctx.strokeStyle = this.active ? 'rgba(173, 216, 230, 0.9)' : 'rgba(173, 216, 230, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.stroke();
                
                // 画中心点
                ctx.fillStyle = this.active ? 'rgba(173, 216, 230, 0.6)' : 'rgba(173, 216, 230, 0.2)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.active) {
                    // 画风的方向箭头
                    const endX = this.x + this.direction.x * 100;
                    const endY = this.y + this.direction.y * 100;
                    
                    ctx.strokeStyle = 'rgba(173, 216, 230, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // 箭头
                    const angle = Math.atan2(this.direction.y, this.direction.x);
                    ctx.fillStyle = 'rgba(173, 216, 230, 0.7)';
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - 10 * Math.cos(angle - Math.PI/6), endY - 10 * Math.sin(angle - Math.PI/6));
                    ctx.lineTo(endX - 10 * Math.cos(angle + Math.PI/6), endY - 10 * Math.sin(angle + Math.PI/6));
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }
        
        // 游戏状态
        let currentLevel = 1;
        let girl = new Girl(50, GAME_HEIGHT / 2 - GIRL_SIZE / 2);
        let obstacles = [];
        let blockages = [];
        let gaps = [];
        let movables = [];
        let wind = new Wind();
        
        // 第一关的布局
        function setupLevel1() {
            obstacles = [];
            blockages = [];
            gaps = [];
            movables = [];
            
            // 中间的障碍物（挡住直路）
            obstacles.push(new Obstacle(350, 160, 80, 80));
            
            // 下方的遮蔽物（盖住绕路的入口）
            // waypoint在遮蔽物下方更远的地方
            const detourWaypoint = { x: 400, y: 340 };
            blockages.push(new Blockage(
                320, 250, 150, 50, 
                { waypoint: detourWaypoint }
            ));
        }
        
        // 第二关的布局
        function setupLevel2() {
            obstacles = [];
            blockages = [];
            gaps = [];
            movables = [];
            
            // 中间的缺口（稍微调整位置和大小）
            gaps.push(new Gap(330, 180, 120, 50));
            
            // 缺口下方的木板（尺寸和缺口差不多）
            movables.push(new Movable(320, 280, 130, 45, 'plank'));
        }
        
        // 加载关卡
        function loadLevel(level) {
            currentLevel = level;
            girl = new Girl(50, GAME_HEIGHT / 2 - GIRL_SIZE / 2);
            
            if (level === 1) {
                setupLevel1();
            } else if (level === 2) {
                setupLevel2();
            }
        }
        
        // 初始化
        loadLevel(1);
        
        // 输入处理
        let mouseX = GAME_WIDTH / 2;
        let mouseY = 50;
        let activeKeys = new Set(); // 追踪按下的键
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            wind.setPosition(mouseX, mouseY);
        });
        
        document.addEventListener('keydown', (e) => {
            // 防止重复触发
            if (activeKeys.has(e.key.toLowerCase())) return;
            
            if (['w', 'W', 'a', 'A', 's', 'S', 'd', 'D'].includes(e.key)) {
                e.preventDefault();
                activeKeys.add(e.key.toLowerCase());
                
                // 设置方向并激活风
                wind.setDirection(e.key);
                wind.activate();
                wind.checkBlockages(blockages);
            } else if (e.key === 'r' || e.key === 'R') {
                // R键重置当前关卡
                loadLevel(currentLevel);
            } else if (e.key === '1') {
                // 切换到第一关
                loadLevel(1);
            } else if (e.key === '2') {
                // 切换到第二关
                loadLevel(2);
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (['w', 'W', 'a', 'A', 's', 'S', 'd', 'D'].includes(e.key)) {
                activeKeys.delete(e.key.toLowerCase());
                
                // 如果没有WASD按键了，停止风
                if (!activeKeys.has('w') && !activeKeys.has('a') && 
                    !activeKeys.has('s') && !activeKeys.has('d')) {
                    wind.stop();
                }
            }
        });
        
        // 游戏循环
        let lastTime = Date.now();
        
        function gameLoop() {
            const now = Date.now();
            const dt = (now - lastTime) / 1000; // 转换为秒
            lastTime = now;
            
            // 更新可移动物体
            for (let obj of movables) {
                obj.update(dt);
            }
            
            // 检查缺口是否被填满
            for (let gap of gaps) {
                gap.checkFilled(movables);
            }
            
            // 更新女孩
            girl.update(dt, obstacles, blockages, gaps);
            
            // 如果风在激活，推动可移动物体并检查遮蔽物
            if (wind.active) {
                wind.pushMovables(movables);
                wind.checkBlockages(blockages);
            }
            
            // 清空画布
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // 绘制
            // 先画缺口
            for (let gap of gaps) {
                gap.draw(ctx);
            }
            
            // 画障碍物和遮蔽物
            for (let obs of obstacles) {
                obs.draw(ctx);
            }
            for (let blockage of blockages) {
                blockage.draw(ctx);
            }
            
            // 画可移动物体
            for (let obj of movables) {
                obj.draw(ctx);
            }
            
            // 画风
            wind.draw(ctx);
            
            // 画女孩
            girl.draw(ctx);
            
            // 画目标指示
            ctx.strokeStyle = '#4a4';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(GAME_WIDTH - 60, GAME_HEIGHT / 2 - 30, 50, 60);
            ctx.setLineDash([]);
            
            // 关卡指示
            ctx.fillStyle = '#aaa';
            ctx.font = '16px sans-serif';
            ctx.fillText(`关卡 ${currentLevel}`, 20, 30);
            
            // 调试信息
            const gapCoverage = gaps.length > 0 && gaps[0].coverageRatio !== undefined 
                ? (gaps[0].coverageRatio * 100).toFixed(1) + '%' 
                : 'N/A';
            
            debugInfo.innerHTML = `
                关卡: ${currentLevel} | 
                女孩状态: ${girl.state} | 
                位置: (${Math.round(girl.x)}, ${Math.round(girl.y)}) | 
                缺口覆盖: ${gapCoverage} (需>50%) | 
                缺口填满: ${gaps.filter(g => g.isFilled).length}/${gaps.length} | 
                遮蔽物: ${blockages.filter(b => b.blocked).length}
            `;
            
            requestAnimationFrame(gameLoop);
        }
        
        // 启动游戏
        gameLoop();
    </script>
</body>
</html>
